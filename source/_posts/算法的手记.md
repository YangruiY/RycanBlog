---
title: 算法的手记
tags: 算法
description: 算法相关学习笔记
sticky: 1
top_img: ./img/7.jpg
cover: ./img/《白蛇2青蛇劫起》小青4k壁纸3840x2160_彼岸图网.jpg
abbrlink: 7608
date: 2023-06-24 13:14:51
---
<meta name="referrer" content="no-referrer" />

## ACM题解注意



### 输入输出

```java
 String str = scanner.nextLine();   整行读入
 String[] s = str.split(" ");    将读入的行按“ ”分割
 Integer.parseInt(c);   将字符串c  转为  整数
 System.out.println(String.join(" ",s1));    在s1中加上空格

Q:

输入数据有多组, 每行表示一组输入数据。
每行不定有n个整数，空格隔开。(1 <= n <= 100)。
    
1 2 3
4 5
0 0 0 0 0




A:
import java.util.Scanner;
public class TestMain {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
            while (scanner.hasNext()) {
                int sum =0;
                String num = scanner.nextLine();  //Line
                String[] s = num.split(" ");
                for(String c:s){
                    sum += Integer.parseInt(c);
                }
                System.out.println(sum);
            }

    }
}






Q:
输入有两行，第一行n
第二行是n个字符串，字符串之间用空格隔开
    
5
c d a bb e

a bb c d e




A:
import java.util.Arrays;
import java.util.Scanner;

public class TestMain {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        String s[] = new String[a];
            for (int i = 0; i < a; i++) {
                String  num = scanner.next();
                 s[i] = num;
            }
            Arrays.sort(s);
            for (String c : s) {
                System.out.print(c+" ");
            }
        }
}




Q:
多个测试用例，每个测试用例一行。
每行通过空格隔开，有n个字符，n＜100
    
a c bb
f dddd
nowcoder
    
    
a bb c
dddd f
nowcoder
    
    
A:
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()) {
            String str = scanner.nextLine();
            String[] s = str.split(" ");
            Arrays.sort(s);
            System.out.println(String.join(" ",s));
        }
    }
}



Q: 两数之和     输入有多组测试用例，每组空格隔开两个整数
0<a,
b<2×10的10次方
     
A:
 public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()) {
            String str = scanner.nextLine();
            String[] s = str.split(" ");
            int n= s.length;
            Long sum = 0L;
            for(int i=0; i<n; i++) {
                sum += Long.parseLong(s[i]);
            }
            System.out.println(sum);
        }
    }


//res   转为   String数组
String[] strings = res.toArray(new String[res.size()]);
```

### 树

#### 创建节点

```java
//先创建HeroNode结点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;.//默认null
    private HeroNode right;//默认null
    
    public HeroNode(int no,String name){
        this.no=no;
        this.name=name;
    }
    public int getNo(){
        return no;
    }
    public void setNo(int no){
        this.no = no;
    }
    public String getName(){
		return name;
    }
    public void setName(String name){
        this.name = name;
    }
    public HeroNode getLeft(){
        return left;
    }
    public void setLeft(HeroNode left){
        this.left=left;
    }
    public HeroNode getRightO{
        return right;
    }
    public void setRight(HeroNode right){
        this.right right;
    
    }
    @Override
    public String toString(){
        return "HeroNode [no="no "name="name "]";
    }
    
    //前序遍历
    public void preOrder(){
        System.out.println(this);//先输出父结点
        //递归向左子树前序遍历
        if(this.left !null){
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if(this.right !=null){
            this.right.preOrderO;
        }
    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树中序遍历
        if(this.left !null){
            this.left.infixOrder();
        }
        //输出父结点
        System.out.println(this);
        //递归向右子树中序遍历
        if(this.right !null){
            this.right.infixOrderO;
        }
    }  
    //后序遍历
    public void postOrder(){
        if(this.left !null){
            this.left.postOrderO);
        }
        if(this.right !null){
            this.right.postOrderO;
        }
        System.out.println(this);//先输出父结点
    }
}
```

#### 建树：

```java
//定义一颗二叉树
class BinaryTree{	
    private HeroNode root;
    public void setRoot(HeroNode root){
        this.root=root;
    }
//前序遍历
    public void preOrder(){
        if(this.root !=null){
            this.root.preOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
//中序遍历
    public void infixOrder()){
        if(this.root !=null){
            this.root.infixOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
//后序遍历
    public void postOrder(){
        if(this.root !=null){
            this.root.postOrderO;
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
}
```

#### 使用树

```java
public static void main(String[]args){
    //先需要创建一颗二叉树
    BinaryTree binaryTree new BinaryTree();
    //创建需要的结点
    HeroNode root=new HeroNode(1,"宋江");
    HeroNode node2=new HeroNode(2,"吴用");
    HeroNode node.3=new HeroNode(3,"卢俊义");
    HeroNode node4=new HeroNode(4,"林冲");
	HeroNode node5=new HeroNode(5,"关胜")；
	//我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
    root.setLeft(node2);
    root.setRight(node3);
    node3.setRight(node4);
    node3.setLeft(node5);
    binary Tree.setRoot(root);
//测试
    System.out.printlne("前序遍历");//1,2,3,5,4
    binaryTree.preOrder();
//测试
    System.out.println("中序遍历");
    binaryTree.infixOrder();//2,1,5,3,4
//测试
    System.out.println("后序遍历");
    binaryTree.postOrder();//2,5,4,3,1
}
```





## 力扣解题时注意











## 数学

#### 质数

>```java
>boolean isPrim(int x) { /* 质数判断 */
>   if (x == 1) {
>       return false;
>   }
>   for (int i = 2; i <= Math.sqrt(x); i++) {
>       if (x % i == 0) {
>           return false;
>       }
>   }
>   return true;
>}
>
>```

#### 回文数

>```java
>public boolean isPalindrome(int x) {
>   if(x< 0) return false;
>   int tmp = x;
>   int y = 0;
>   while(tmp>0){
>       int last_num = tmp%10;
>       tmp = tmp/10;
>       y= y * 10 + last_num;
>   }
>   return y == x;
>}
>```







## 二叉树



### <递归>三步分析法

##### **确定递归函数的参数和返回值：**

确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

>二叉树的参数一般都是   ==根节点  +   数组== （存放遍历的元素）

##### **确定终止条件：**

写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

##### **确定单层递归的逻辑：**

确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 纲领：

两种思维：<都是递归>

- 遍历—— 回溯   使用 **traverse函数** 的遍历递归      traverse + 外部变量
- 分解问题——dp/分治   使用**非traverse函数** 递归       函数 + 返回值

二叉树**遍历框架**都是 递归 的



三个特殊时间点

> 前序位置的代码在==刚刚进入==一个二叉树节点的时候执行
>
> >**前序位置的代码 只能 从函数参数中获取父节点传递来的数据**
>
> 后序位置的代码在==将要离开==一个二叉树节点的时候执行
>
> >**后序位置的代码  不仅  可以获取参数数据，还可以  获取到子树通过函数返回值传递回来的数据**
>
> 中序位置的代码在一个二叉树节点左子树都遍历完，==即将开始==遍历右子树的时候执行

```java
104 最大深度和
// 递归，分解子问题最为简单 
    
----子问题    1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  （此处有） int XX= XXmethod();
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多
    //求深度所以结果加1
    
144 前序遍历
// traverse 函数不会有问题，在前序遍历的位置上有add操作
    
543 直径
    // 利用104求深度的函数，104结果未+1时，所求的就是所谓的直径，所以在这时候直接求和进行对比替换

 ----子问题    1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  （此处有） int XX= XXmethod();
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多
    
// 分解子问题的时候要进行比较，
    也就是说
    	要求直径必先求深度，因为就单边而言 直径的距离是小于深度的
    此处就是在求深度的时候加上了两行代码
    	// 求直径
    	int lfsum =  leftdepth+rightdepth;
        // 计算左右之和最大值并进行替换结果值
        maxdis = Math.max(lfsum,maxdis);
		其中leftdepth 和 rightdepth的大小就是由调用自己的深度而来
         但是这个+1才是深度，此处没有在最终结果中 +1 ，所以就是直径，直径之和  和  maxdis 比较得到结果，随后递归即可 
```

### 思路：

```java
	226 反转二叉树  
----子问题    1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值   (不一定有)  （此处有）
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多   
   	//这里也是，子问题视为已经将所有子树进好了反转，现在需要对 root 进行翻转就可以了，所以就是
        root.right = leftnode;  
        return root;
// 但是这里调换显然是要用到左右子树 调换的 结果 才能进行左右子树调换，所以也要对递归函数进行赋值才能调用    需要  利用子问题的返回值
   


   116 填充节点的右侧指针 
    
        //该判空就判空，改为 三叉树 
        // 使用next进行连接
        // 直接就是一个遍历，traverse 

       
       
   
   114 二叉树展开为链表
----子问题    1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【不可赋值】
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多   
       在这里的给定函数 void  flatten(){}  就是经过拉直之后得到的结果，所以皆可以直接将其视为最终结果，
       在root.left   root.right  之后就可以直接对 根节点 进行模拟合并操作，其对于所有的其他节点一样适用，但是函数返回值是  void 所以不可以赋值   只能另外 赋值给临时变量，值为对 root.left，root.right 之后就可以直接在   root.left，root.right   进行操作了
       
       
       
     
       注意：子问题和源问题的思路 目标 是一样的 ，甚至结果也只是缩小化原问题的结果
        		// 所以可以直接对得到子问题的结果进行操作，交换，重排序等等
      	// 就像是这里，子问题的结果 是将 左右子树的 结果拉成一条链， 原问题是将所有节点拉成一条链
		// 所以当然就直接对两个子结果及操作就可以了，左边移动过去，右边的结果接到左边最后的位置
        // 别忘了要对树的 左边置 null 
  
```

### 构造问题

**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。



```java
 654 由数组构造最大二叉树
----子问题    1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  
     
 思考1--自己构建函数需要的参数？   已知的只有数组   那就是  nums 数组的起始坐标
	如此一来，就可以不断地递归从而缩小数组的大小，就能够构建出值
   给定函数：TreeNode constructMaximumBinaryTree  ，所以设置的函数也是 TreeNode 返回值类型的
     //找到根节点    
     此处就是maxVal 辅助变量  Integer.MIN_VALUE,对数组循环比较得到根节点值，并由此值 构建出树。
思考2---   //构造左子树，右子树   // 显然是两个遍历。  重点就是 填参数-----起始坐标 就是取得最大值时遍历的数组下标  所以还需要对数组下标 设置对应变量   进行返回
思考1-    显然方法要有返回值的，这里的返回值就是 TreeNode 型的 ，而且再结果返回的还是 root<自定义的树的变量>   所以便利的时候返回值就设置为  .left   .right 
    
  
     -- 下面三题考虑 子问题的 思路与这里近乎一致只是在细节上有优化   【下面三个全赋值】
     优化一： HashMap<Integer, Integer> inmap = new HashMap<>();
             for (int i = 0; i < inorder.length; i++) {
                        inmap.put(inorder[i], i);
                    }
				双数组， hashMap 便于取下标值 （所以put的时候  k:数组的值， v:下标）
      区别：上面的是找max    下面的是努力找根节点。
                    
      下面流程都是近乎一致的：
                    // 这里找根节点的值和位置   注意这两个操作 是要在两个数组中进行的
        --注意 889  这里是有些区别，这里的根节点值很好确定，所以并不能由此获得位置，需要再在先序遍历中找到左边的第一个节点，根左右  ，第一个就是根，在后序中，左右根，根恰好就是分隔点，所以应该找 preorder 里面的左子树的根，然后去 postorder 中找位置， 反之，从postorder 找值 preorder 中找位置  是无法得到左子树准备的数量的
                    // 左子树长度
                    // new 一棵树 root（根据根节点的值）
                    // 递归      --  也要赋值的
                    //return       root
                    
            除此之外就是细节问题，递归时索引的值，左子树长度  需要格外注意 
105 通过前序和中序遍历结果构造二叉树

     
        
106 通过后序和中序遍历结果构造二叉树

   
889 通过后序和前序遍历结果构造二叉树（**）
    
     
     
```



### BST

二叉搜索树「中序遍历有序」

BST 相关的问题

​	要么利用 BST 左小右大的特性提升算法效率

​	要么利用中序遍历的特性满足题目的要求

- 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。

- 通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。

```java
  利用中序排序的特点， 有序的 ，所以大部分代码应该写在中序位置上的

230 「 二叉搜索树中第 K 小的元素」 -- 显然是要排序的 
      
 traverser函数 ，在中序位置上进行检索就OK了  
    
538   1038  BST 转化累加树
    
traverser函数 ，对逆序的序列进行加值赋值操作   还是在中序位置上进行操作 就OK了  

  
      
      
      
BST 框架
    void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
      
     
 
700   搜索子树
 ---子问题：  1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  
    返回值： TreeNode   ，要赋值  利用bst 模版  直接将分类的搜索遍历结果/**视为最终结果 */返回（也可以赋值，返回赋值的值）
    
      
701  插入操作。
      同理 
 ---子问题：  1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  
    返回值： TreeNode   ，要赋值  利用bst 模版、
    但是这是不能直接返回，此时的左右子树只是一棵树的一部分，要得到最终完好的树，还是需要进行赋值给 root.left  root.right 的，最后 return root  这样就能直接得到一棵插好元素的树了
    
450 删除
 ---子问题：  1、因为需要 左右函数的递归值，所以要在递归时进行变量赋值 (不一定有)  【赋值】
			 2、所有利用子问题求解的函数经过多次递归最终会得到答案，所以直接就都视为  已经得出答案的函数，这样在调动用的时候就不用想太多  
    返回值： TreeNode   ，要赋值  还是要利用bst 模版
      同样：但是这是不能直接返回，此时的左右子树只是一棵树的一部分，要得到最终完好的树，还是需要进行赋值给 root.left  root.right 的，最后 return root  这样就能直接得到一棵 删完 元素的树了
      但是区别是：
      与搜索插入不同的是：这里的删除是要分类讨论的，root.val == val 时分三种情况讨论，其中讨论的时候还是会进行调用的   ---- 可以细品
      
      另外还调用了 最小值得函数（非递归） 
      
    
98 判定
      通过 450 给予的启发  直接定义最大 最小函数，由此获得左子树的最根节点，右子树的最左根节点  随后对给定函数进行判定 
    	判定条件就是左非空就要左小根  右非空就要右大根《这里的左右根节点的值 就是通过上述函数 .val 获得的》 否则false;   = 也是false
      boolean 可以赋值也可以直接返回。
      
    
  
```



## 链表



1、**子问题（后面这部分链表）和原问题（整条链表）的结构完全相同，这就是所谓的递归性质**

2、**递归函数都有个 base case**

```java
206     反转链表
    
    就用while循环写
    ListNode pre,cur,nxt;
          pre = null;
          cur = nxt = head;
             while(cur!= null){
                 nxt = cur.next;
                 cur.next = pre;
                  pre = cur;
                  cur = nxt;              
             }
	return pre ;
    
92
    
//206 92  递归的区别：  1 basecase  前者：if (head == null || head.next == null) {return head;}  
							//后者：base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。
    				//2、前者不要链接未反转的点， 直接把 head.next 设置为 null
    				//   后者需要  要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。
1、当  left =1 时要分开讨论。
    while 循环
   ListNode reverse(ListNode head, int right){   // 这里给的是第几个接点
        ListNode pre,cur,b,nxt;
        b=cur = nxt= head;
        pre = null;
        //得到第right个节点的位置
        for(int i = 0 ;i<right;i++){
            if(b == null) return head;
            b = b.next;
        } 
        while(cur != b){
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // 头指针指向尾部
        head.next = b;
        return pre;
   }

2、 left != 1 时就进行递归
  		// 开始递归
       a.next = reverseBetween(head.next,left-1,right-1);   
			// 这里的a.next 就是将 进行将指针进行翻转遍历的
25
    每 k 个节点一组进行翻转
                
    1、找到对应的节点
                 ListNode a,  b;  
          a =b = head;
          for(int i=0 ;i<k;i++){
              if( b == null)  return head;
              b=b.next;
          }
      
	2、还是调用 while  循环进行遍历 此时遍历得到对应的节点，下进行稍微改动
         ListNode reverse(ListNode head,ListNode node) {
            ListNode pre=node,nxt=head,cur=head;
            while(cur != node){
                nxt = cur.next;
                cur.next = pre;
                pre = cur;
                cur = nxt;
            }
            return pre;
		}

  	3、  
         ListNode res = reverse(a,b);  // 先反转从头开始的前面几个节点
			//再进行下面的递归,每次递归就又是上一次的b为头，开始新的一轮递归 并将a.next (head的下一个 指向新的反转链表的指针)
		//此处的 a.next 很关键。a此时是将 头结点指向下一个要反转的头节点
         a.next = reverseKGroup(b, k); 
 

//其实这里的1 2 两步骤  和上一问的while 循环其实是一样的  ，可以随意替换
    
234
    
    //首先先找到中点，然后将中间点开始将后面的字符串进行翻转最后进行比较、
    找中间节点      双指针
    反转：   while 循环
    比较    指针向中间移动
    
```



## 数组











## 字符串





#### 回文串

>==中心扩展法：==
>
>实质的思路和动态规划的思路类似。
>
>- 比如对一个字符串` ababa`，选择最中间的 `a `作为`中心点`，往两边扩散，
> - 第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。
>
>这个是确定了一个中心点后的寻找的路径，然后我们`只要寻找到所有的中心点，问题就解决了`。
>
>- 中心点一共有多少个呢？
> - 看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，
    >   - 想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。
> - 所以中心点不能只有单个字符构成，还要包括两个字符，
    >   - 比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由` 2 * len - 1` 个，分别是 `len 个单字符`和 `len - 1 个双字符`。
>
>如果上面看不太懂的话，还可以看看下面几个问题：
>
>- 为什么有 2 * len - 1 个中心点？
> - aba 有5个中心点，分别是 a、b、c、ab、ba
> - abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba
>
>- 什么是中心点？
> - 中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个
>- 为什么不可能是三个或者更多？
   >  因为 3 个可以由 1 个扩展一次得到，4 个可以由 2 个扩展一次得到
>
>```java
>//5  最长回文子串
>
>String res= "";
>   public String longestPalindrome(String s) {
>       for (int i = 0; i < s.length(); i++) {
>          String oddString= substr(s,i,i);
>          String evenString = substr(s,i,i+1);
>          res = res.length()<oddString.length() ? oddString:res;
>          res = res.length()<evenString.length()? evenString:res;
>       }
>      return  res;
>   }
>   //      回文串        左边中点   右边中点
>   private String substr(String s, int i, int j) {
>       while(i>=0 && j<s.length() && s.charAt(i)==s.charAt(j)){
>           i--;
>           j++;
>       }
>       //因为上面已经 ++  -- 过了
>       return s.substring(i+1,j);
>
>   }
>
>// 647 回文子串   
>public int countSubstrings(String s) {
>   int count = 0;
>       for (int i = 0; i < s.length(); i++) {
>           count += substr(s,i,i);
>           count += substr(s,i,i+1);
>       }
>   return count;
>   }
>               //      回文串      左边中点  右边中点
>   private int substr(String s, int i, int j) {
>       int res= 0;
>       while(i>=0 && j<s.length() && s.charAt(i)==s.charAt(j)){
>          // System.out.println(s.substring(i,j+1));
>           i--;
>           j++;
>           res++;
>       }
>       return res;
>   }
>
>```
>
>**推荐还是中心扩散法**
>
>```java
>DP 的写法
>//5
>//动态规划
>   public String longestPalindrome(String s) {
>       int length = s.length();
>       //特殊情况  ,空串  就返回空
>       if (s == null || length == 0)
>           return "";
>       if (length == 1)
>           return s;
>       //定义下列变量，分别表示开始位置 结束位置 的变量 以及 最大长度。
>       int begin = 0, end = 0,subLen = 1;
>       //定义动态二维数组
>       boolean [][] dp = new boolean[length][length];
>
>       //动态规划的数组是从列开始填写表格的
>          for (int i = s.length()-1; i >=0 ; i--) {
>           for (int j = i; j < s.length(); j++) {
>               if (s.charAt(i)==s.charAt(j)  && (j-i <= 2 || dp[i+1][j-1])){
>                  dp[i][j] = true;
>
>                  if(j-i+1> subLen){
>                   subLen = j-i+1;
>                   begin = i;
>                  }
>               }
>           }
>       }
>       //返回子串的，开始位置以及结束位置
>       return s.substring(begin,begin+subLen);
>   }    
>
>
>
>
>
>// 647   
>   public int countSubstrings(String s) {
>       int res=0;
>       //dp[][]
>       boolean dp[][] = new boolean[s.length()][s.length()];
>       //递推公式s[i] ==s[j] ①j-i=0  ②j-i=1 ③dp[i+1][j-1]    VS  s[i] !=s[j]
>       //初始化dp[][]
>       for (int i = 0; i < s.length(); i++) {
>           dp[i][i] = true;
>       }
>       //遍历顺序
>       for (int i = s.length()-1; i >=0; i--) {
>           for (int j = i; j < s.length(); j++) {
>               if(s.charAt(j) == s.charAt(i) && (j-i<2 || dp[i+1][j-1])){      // j-i<2 必须要写在前面
>                       res++;
>                       dp[i][j] = true;
>
>               }
>           }
>       }
>       return res;
>       //打印dp数组
>   }
>```
>
>





#### 一般串

>43 : 给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。
>
>```java
>class Solution {
>public String multiply(String num1, String num2) {
>    if("0".equals(num1) || "0".equals(num2)) return "0";
>   //结果集的接收
>   int res[]=new int[num1.length()+num2.length()];
>   //从最低位开始相乘， -'0'是 Char字符 转为数字的方式
>   for(int  i = num1.length()-1;i>=0;i--){
>       int t1 =  num1.charAt(i)-'0';
>       for(int j = num2.length()-1;j>=0;j--){
>           int t2 = num2.charAt(j)-'0';
>            int sum = res[i+j+1]+t1*t2;
>            // 低位是取余的结果
>            res[i+j+1] = sum % 10;
>            // 高位进行 取模
>           res[i+j] += sum / 10;
>       }
>   }
>   StringBuilder stringBuilder = new StringBuilder();
>    // 去除前面几位的0
>   for(int i=0;i<res.length;i++){
>       if(i==0 && res[i] == 0) continue;
>       stringBuilder.append(res[i]);
>   }
>   return stringBuilder.toString();
>}
>}
>```
>
>

#### 数字与串

>```java
>String s = "8264";
>int number = 0;
>for (int i = 0; i < s.size(); i++) {
>// 将字符转化成数字
>number = 10 * number + (s[i] - '0');
>print(number);
>}
>// 打印输出：
>// 8
>// 82
>// 826
>// 8264
>```
>
>







## 双指针对链表:

#### 技巧

技巧一

- 合并分解双指针

    - 当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理、防止空指针的的情况

    - 让你把两条有序链表合并成一条新的有序链表（合并两个有序链表）、把一条链表分解成两条链表时(单链表分解)


技巧二：快慢指针

- 一条链表的间隔双指针（找到倒数第K个节点，删除第n个节点）

- n倍速快慢指针（中间节点 是否有换  是否是环  环的交点在哪   是否相交  ）





  ```java
  23 合并多个升序列表<难题>
  
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode() {}
   *     ListNode(int val) { this.val = val; }
   *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   */
  class Solution {
      public ListNode mergeKLists(ListNode[] lists) {
              //难题：
          if(lists.length == 0) return null;
          ListNode  list = new ListNode(-1);
          ListNode p = list;
  
          PriorityQueue<ListNode> pq = new PriorityQueue<>(
              lists.length,
              (a,b)->(a.val-b.val)
          );
  
          for(ListNode list1:lists){
              if(list1!=null){
                  pq.add(list1);
              }
          }
          while(!pq.isEmpty()){
              ListNode node = pq.poll();
              p.next = node;
              if(node.next != null){
                  pq.add(node.next);
              }
              p = p.next;
          }
          return list.next;
      }
  }
  ```

#### 大致核心模块

```java
// 定义双指针
ListNode fast = head;
ListNode slow = head;
// 一者
while(fast != null && fast.next != null ){
   fast = fast.next.next;
   slow = slow.next;
   ......
}
// 再者
	while( q!=null){       //while(p1!= null && p2 != null)
           if(q.val < x){
               s.next = q;
               s= s.next;              
           }else{
               b.next = q;
               b=b.next;
           } 
        ......
    }
```

####  题解

  ```java
// 快慢指针 链表

141 链表是否有环
    
    // 返回值 boolean
    // 定义快慢指针,初始值为head; ---唯二的变量
    //  while(fast != null && fast.next != null  && fast.next.next != null)循环条件
    
142 环的节点在哪
    // 返回值 ListNode
    // 定义快慢指针,初始值为head; ---唯二的变量
    //  while(fast != null && fast.next != null  && fast.next.next != null)循环条件1 
    // 单独判断一下 if(fast == null || fast.next == null) return null;
    // 慢指针从头开始，再一次  while(slow != fast) 循环
876 找中间点
    //// 返回值 ListNode
    // 定义快慢指针,初始值为head; ---唯二的变量
    //  while(fast != null && fast.next != null)循环条件
    
---- 上面的 三题均是在 循环条件一 中进行  fast = fast.next.next;  slow = slow.next; 操作  其他操作是细致末节的变化
    
    
160 两个链表相交的点
    // 两个链表，所以要有两个指针   ---唯二的变量
    // 两个链表长短不一，依次一次遍历，重合即为交点
    //循环条件 while(p1 != p2)
    
---  创建虚拟链表头结点

19 删除倒数第n个节点
    //创建辅助链表,虚拟链表头结点demo （-1）     一个变量 
    //demo.next =head;
    //调用找第k个元素的方法找到第len-n+1个元素  传的参数就要是 定义的虚链表
    	//定义快慢指针  ---唯二的变量
    	//for(int i=1;i<k;i++)   fast 先跑的间隔
    	//循环条件 while(fast.next != null)
 	// 删除找到节点的下一个节点
	// demo 全程不参加工作，只有在创建的时候指向原链表，所以输出的返回值就是：demo.next
    
   
86 分隔链表
    // 一分为2   2个虚拟链表头结点  small  big   原链表还是用head   换做变量 p对原链表操作  进行获取      --- 3 变量 + 1 临时变量
    //虚拟节点不参与工作，所以对这两个表头结点再次进行创建对应的 操作节点 s b
    //循环条件中  while( q!=null)    q 置为head,表示让q对该链表进行循环获取      --  只比较当前值
    		//中比较大小，小的进 s ，s继续后移    大的进 b   b继续后移    
    		//重点:断开原链表中的每个节点的 next 指针,否则会成环	
    			// ----- 怎么断 -->  临时变量存储p 当前值p.next      p置为 null      p进行赋值保证循环继续执行
   // big  就是	b对应的结果集，但是big 为虚拟的，也就是说   big.next才是b   
   // s 是一直后移的 所以s.next = big.next   将 big.next 赋值给s
   //同理 返回的就是small.next
    
    
    
21 合并链表
	//二合一   两个原链表  list1 list2  一个新链表  list 但是都不能直接操作，所以  要2个虚拟链表头结点  small  big对老链表进行操作 以及一个 p 对新建的链表进行操作 
    		// 3变量
    //while(big!= null && small != null) 比较大小，  -- 只比较当前值
    			//值小的 就进新链表，small 后移  /big后移      并将当前值存到 p的下一个值    比完大小  -------> 特色：p持续后移  -- 否则值将被覆盖
    //比完必有一个且只有一个（只比较当前值） ，所以分开判断  逻辑都是，直接加到新链表，p.next = small /big;
    //同理 返回的就是list.next
    
    
  ```

## 双指针对数组

#### 题解

  ```java
// 快慢指针 数组
// 此处的数组全是原地操作，不能new 新的
26 数组原地去重   --不能new 一个新的数组            第一个值肯定是保留的  
//分析：已经排好序的，删除会涉及 索引的变化
// fast slow  两个指针，
    //特点：先++ 再赋值，fast 初始值= 1 /0 都可以
    		// 因为此时slow是有值的，第一个值肯定是保留的
	//while(fast<nums.length){循环
            //if(nums[fast] != nums[slow]){ 原地操作的判定
    
83  删除排序列表中重复元素                          第一个值肯定是保留的
//链表  值得比较 是  .val
    // fast slow  两个指针，
    //while(fast!= null){循环
          //if(fast.val != slow.val){ 原地操作的判定
    // 先链接再后移指针
----------//重点: 断开与重复元素的链接
        //slow.next = null;
27 数组中的某些元素进行「原地删除」                第一个值不一定是保留的
    // fast slow  两个指针
    //while(fast<nums.length){循环
            //if(nums[fast] != val ){ 原地操作的判定   -- 特定值val
   // 后++  先赋值    因为第一个值不一定是保留的   此时的slow是不一定有值的
283 移动0
    // fast slow  两个指针
    //while(fast<nums.length){循环
            //if(nums[fast] != 0 ){ 原地操作的判定   -- 特定值     0
   // 后++  先赋值    因为第一个值不一定是保留的   此时的slow是不一定有值的
   //后面的值全为0  就是要从 slow+1 （位置）/    -1（角标） 到 fast  角标【low,fast)全置为 0
         //if(fast>slow){
            // for(int i=slow; i <fast;i++){
            //    nums[i] =0;
            //}
    
    
    
// 左右指针 数组
167 两数和
   // left right 左右两指针，> target 就right-- 否则++ 直到 else (不能丢)   return
    
344 反转数组
    //left right 左右两指针  经由辅助变量（设立辅助变量）进行交换   随后指针++  -- 
    
5 最长回文串
    
    // 递归
    // 递归函数：
    //  中间向两边扩展   ++    --
    public String Palindrome(String s, int start,int end){
        while(start> -1 && end<s.length()
                && s.charAt(start)==s.charAt(end)){
            start--;
            end++;
        }
    // 返回子串
        return s.substring(start+1,end);
    }



	//调用递归
	 public String longestPalindrome(String s) {
        int length = s.length();
        String nowStr = "";
        for(int i = 0;i<length;i++){
            String odd =  Palindrome(s,i,i);
            String even =  Palindrome(s,i,i+1);
		//这里断点调试之后发现  要判定  不然会出现bug ,否则会使nowStr 的较大的值被替换成为新的小值 
        if(nowStr.length()< even.length()  || nowStr.length()< odd.length() )
            nowStr = even.length() > odd.length()?even:odd;
        }
        return nowStr;
    }
  ```

#### 原地处理数组大致模版

```java
 while(fast<nums.length){
            if(nums[fast] != nums[slow]){
                //先++ 再赋值，因为此时slow是有值的，第一个值肯定是保留的
                 slow++;        //①
                nums[slow] = nums[fast];      //②
                
                // 第一个值如果是要保留的，那么顺序就是①②
                // 第一个值如果是不一定保留的，那么顺序就是②①
                
            }
            fast++;
        }
```



## dp

子问题：

最优子结构：

​	**要符合「最优子结构」，子问题间必须互相独立**

​			你只需要把子问题的答案加一，求个最小值，就是原问题的答案。

状态转移方程：

​	**确定 base case**

​	**确定「状态」，也就是原问题和子问题中会变化的**    ==变量==

​	**确定「选择」，也就是导致「状态」产生变化的行为**    所谓的选择就是目前可以选的变量的范围  取值;

​	**明确 `dp` 函数(自顶向下)/数组(自底向上)的定义**

​				一般来说函数的==参数==就是状态转移中会变化的量，也就是上面说到的==「状态」==



> ==注：==
>
> 子串一定是连续的，而子序列不一定是连续的



### 动态规划解法

动态规划的核心设计思想是**数学归纳法**。

可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`

思考状态转移方程的一个基本方法是数学归纳法，即明确 `dp` 函数或数组的定义，然后使用这个定义，从已知的「状态」中推导出未知的「状态」。

动态规划的状态转移关系：

1、明确 `dp` 数组的定义。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了



但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。





>1、到底什么才叫「最优子结构」，和动态规划什么关系
>
>​				可以从子问题的最优结果推出更大规模问题的最优结果  之前的子问题就是最优子结构
>
>​				最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；**但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的**，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路
>
>​				动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质
>
>​				找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的读者应该能体会。



>2、如何判断一个问题是动态规划问题，即如何看出是否存在重叠子问题
>
>​				**首先，最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点**。
>
>​					实际的动态规划问题比较复杂，比如二维甚至三维的动态规划，当然也可以画递归树，但不免有些复杂
>
>​				**可以通过递归框架直接判断是否存在重叠子问题**。
>
>​					从状态 `(i, j)` 转移到 `(i+2, j+2)`，有几种路径？从状态 `(i, j)` 转移到 `(i-1, j-1)`，有几种路径？





>3、为什么经常看到将 `dp` 数组的大小设置为 `n + 1` 而不是 `n`
>
>为什么迭代解法中的 `dp` 数组初始化大小要设置为 `int[m+1][n+1]`？
>
>为什么 `s1[0..i]` 和 `s2[0..j]` 的最小编辑距离要存储在 `dp[i+1][j+1]` 中，有一位索引偏移？
>
>
>
>再看 `dp` 数组，你当然也可以定义 `dp[i][j]` 存储 `s1[0..i]` 和 `s2[0..j]` 的编辑距离，但问题是 base case 怎么搞？索引怎么能是 -1 呢？





>4、为什么动态规划遍历 `dp` 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历
>
>**1、遍历的过程中，所需的状态必须是已经计算出来的**。
>
>**2、遍历结束后，存储结果的那个位置必须已经被计算出来**。
>
>​	主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。



>5、 BASE CASE 和备忘录的初始值怎么定？
>
>base case 的返回值    **起始条件决定的**
>
>备忘录的初始值          **由题目给出的数据范围决定的**
>
>索引越界情况的返回值
>
>5.1、对于不合法的索引，返回值应该如何确定
>
>​		**根据我们状态转移方程的逻辑确定**。对于索引越界的 `dp` 函数，应该返回一个不可能被取到的值。
>
>5.2、base case 为什么是 `i == 0`？
>
>​		**根据 `dp` 函数的定义所决定的**。
>
>5.3、备忘录 `memo` 的初始值为什么是 66666？其他值行不行？
>
>​		**题目给出的数据范围决定的**。`memo`的初始值一定得是特殊值，和合法的答案区间有所区分
>
>注：
>
>​		**不要忽视题目给定的其他信息**



### 动态规划解题组合拳

**就算 `dp` 函数/数组的定义相同，如果你使用不同的「视角」进行穷举，效率也不见得是相同的**。

两种完全不同但都是正确的状态转移逻辑，不过两种逻辑在代码实现上有效率的差异



##### 总结：

```java
	1、basecase            
  		起始条件决定，也是由dp[i]的定义决定      要是使用备忘录：则其初始条件就由题目范围决定 

    2、状态—变量

	3、选择—变量发生变化的行为 可能是变量的取值范围

	4、dp[i] / dp[m][n]  的定义/含义    dp 参数就是状态—变量

  解题思路： 

  数学归纳法：
  					1、dp[i] 的定义/含义
 					2、假设dp[0…i-1] 已知，求dp[i]     从已知推未知

  是否具有重叠子问题：
                    1、画递归数的图
                    2、抽象出 递归框架 进行判断				

  解题注意点：

                dp[]    数组大小是 n+1			dp[][]设置为： [m+1][n+1]		
```



### 五步走：

###### 1、确定dp数组（dp table）以及下标的含义

###### 2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了**dp**数组要如何初始化】

###### 3、dp数组如何初始化

###### 4、确定遍历顺序

###### 5、举例推导dp数组



### 基础问题

>###### 爬楼梯的消费最少
>
>> ```java
>> >  dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
>> ```
>
>
>
>> ###### 不同路径
>
>```java
>dp[i][j] = dp[i-1][j]+ dp[i][j-1];
>
>```
>
>
>
>###### 不同路径II
>
>```java
>if(obstacleGrid[i][j] == 1)  continue;
>dp[i][j] = dp[i-1][j] + dp[i][j-1];  
>```

###### 困难问题

>###### 不同的搜索二叉树
>
>```java
>找规律
>
>// 以 j 为头节点的，左子树有 j-1 个节点   右子树有 i-j 个节点
>dp[i] += dp[j-1]*dp[i-j];
>
>```
>
>###### 整数拆分
>
>```java
>// 拆 i, i-j,循环拆  
>dp[i] = max(j*(i-j),j*dp[i-j],dp[i]);
>
>```



### 背包问题总结大全

- 基础题

- 背包

  01  背包：

>二维数组：
>
>- dp数组含义：
>
>```java
>	即dp[i][j] 表⽰从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少
>```
>
>>要时刻记着这个**dp**数组的含义，下⾯的⼀些步骤都围绕这**dp**数组的含义进⾏的，如果哪⾥看懵了，就来回顾⼀下i代表什么，j又代表什么。
>
>- 递推公式：
>
>```java
>	 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
>
>					不放的时候			放的时候
>```
>
>- 数组初始化
>
>- 遍历顺序
   >
   >  先遍历 物品还是先遍历背包重量都可以
>
>`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 递归公式中可以看出`dp[i][j]`是靠
>
>`dp[i-1][j]和dp[i - 1][j - weight[i]]`推导出来的。`dp[i-1][j]和dp[i - 1][j - weight[i]] `都在`dp[i][j]`的左上⾓⽅向
>
>- 动⼿推导⼀下dp数组
   >
   >  自己推导 和 程序打印
>
>一维数组：
>
>>滚动数组的由来，需要满⾜的条件是上⼀层可以重复利⽤，直接拷贝到当前层
>>其实可以发现如果把dp[i - 1]那⼀层拷贝到dp[i]上，表达式可以是：
>>`dp[i][j] =max(dp[i][j], dp[i][j - weight[i]] + value[i])`; i是物品，j是背包容量
>
>>- ⼀维dp数组中，dp[j]表⽰：容量为j的背包，所背的物品价值可以最⼤为dp[j]。
>>- `dp[j - weight[i]]`表⽰容量为j-weight[i]的背包所背的最⼤价值
    >>  `dp[j - weight[i]] + value[i]` 表⽰ 容量为 `j - 物品i重量` 的背包 + `物品i的价值`
>>- `dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`相对于⼆维dp数组的写法，就是把`dp[i][j]`中`i`的维度去掉了
>>- dp[0] = 0，又因为 是 取价值最⼤的数   所以都初始为0就可以了
>>- 倒序 遍历，就可以保证物品只放⼊⼀次呢  而且必须 先遍历物品嵌套遍历背包容量
>>- 自己推导 和 程序打印
>
>
>
>分割等和子集   /  石头相撞   /
>
>价值  和重量都看做数组中   值的大小



#### 01背包

###### 1、确定dp数组（dp table）以及下标的含义

```java
dp[j]  表示   总容量为 j的  背包  最大值为  dp[j];
```

###### 2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】

```java
绝大多数是：
    
dp[j] = Math.max(dp[j],dp[j-i的重量]+i的价值);
或者
dp[j] += dp[j-i的重量];
```

###### 3、dp数组如何初始化

```java
dp[0] = 0; ----dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]); 


dp[0] = 1; ----dp[j] += dp[j-nums[i]];
```

###### 4、确定遍历顺序

```java
for(int i = 0 ;i < nums.length;i++ ){ //物品  顺序
     for(int j（j表示当前背包剩余重量）= 背包容量;j>= i的重量;j-- ){  // 背包     倒序  保证物品只遍历一次
      
     }
}
```

###### 5、举例推导dp数组



###### 6、总结：

```java
模版框架

 int dp[] = new int[/** 根据题意来设 */];
 dp[0]=  0（max）  (或者是)  1（+=）;
 
 for(int i=0;i<stones.length;i++){					// 物品取值
        for(int j = target ;j>=stones[i];j--){       //背包容量
                dp[j] = Math.max (dp[j],dp[j-stones[i]]+stones[i]);
            //或者
            	dp[j] += dp[j-nums[i]];
        }
 }

	return dp[target]  /sum-2*dp[target]/......

剩下的就是根据 题目 进行 数据预处理 返回值变化等 的填充
    
```

>说明：
>
>`dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);`
>
>` dp[j] += dp[j-nums[i]];`
>
>​	i  、 j 等变量  本质应该为
>
>`dp[背包容量] = Math.max(dp[背包容量],dp[当前背包容量-物品[i]重量] + 物品[i]价值);`
>
>`dp[背包容量] += dp[背包容量-物品[i]重量];`

#### 完全背包

>排列：   先背包   后物品    1,2    2,1   各算一种
>
>组合： 	先物品  后背包    1,2    2,1   只算一种
>
>求最少个数   两种遍历方式  都可以

###### 1、确定dp数组（dp table）以及下标的含义

```java
dp[i]: 凑成⽬标正整数为i的排列个数为dp[i]
dp[j]: 凑⾜总额为j所需钱币的最少个数为dp[j]
dp[i]: 字符串长度为i的话，dp[i]为true，表⽰可以拆分为⼀个或多个在字典中出现的单词。
    ...
一般就是题目问什么你设什么  类比数学归纳法
```

###### 2、确定递推公式【其在前的原因： ⼀些情况是递推公式决定了dp数组要如何初始化】

```java
绝大多数是：
dp[j] = Math.min (dp[j],dp[j-nums[i]]+nums[i]);
或者
dp[j] += dp[j-nums[i]];
```

>==注：这里和01背包问题是一样的==
>
>说明：
>
>`dp[j] = Math.min  (dp[j],dp[j-stones[i]]+stones[i]);`     min
>
>` dp[j] += dp[j-nums[i]];`
>
>​	i  、 j 等变量  本质应该为
>
>`dp[背包容量] = Math.min(dp[背包容量],dp[背包容量-物品[]] + 价值[])（求min 的时候价值很可能为1的）;`   min
>
>`dp[背包容量] += dp[背包容量-物品[]];`

###### 3、dp数组如何初始化

>==注：这里和01背包问题是不太一样的==

```java
这里求的是 min   需要给其他值置初值：   Arrays.fill(dp,amount+1);  
后
dp[0]赋值   dp[0] = 0;	----dp[j] = Math.min  (dp[j],dp[j-nums[i]]+nums[i]);

dp[0] = 1; ----dp[j] += dp[j-nums[i]];
```

###### 4、确定遍历顺序

```java
《组合》
for(int  i = 0;i<coins.length;i++){    //物品
        for(int j=coins[i] ; j <= amount;j++){      //背包    正序，物品可重复
            
        }
    }

或者  《排列》
for(int i= 0;i<=target;i++ ){						//背包
     for(int  j=0;j < nums.length;j++){             //物品
             if(i>=nums[j]){ //等于 不能丢          //此时要多一个条件  																  原因在于：j-nums[i]>0
             
             }
      }
}
```

>==注==
>
>先物品后背包:   `组合`
>
>​		是一种组合 是没有固定顺序的 比如  1,2,1   1,1,2 视为一种方法
>
>​		在这种便利条件下  1,2,1   1,1,2  只会出现一种情况
>
>先背包后物品:   `排列`
>
>​		是一种排列 是 有固定顺序的 比如  1,2,1   1,1,2 视为两种方法
>
>​		在这种便利条件下  1,2,1   1,1,2  都会出现
>
>​		注意`if(i>=nums[j])`不能丢

###### 5、举例推导dp数组



###### 6、总结：

```java
模版框架

 int dp[] = new int[/** 根据题意来设 */];
 dp[0]=  0  (或者是)  1;
 
for(int  i = 0;i<coins.length;i++){
      for(int j=coins[i] ; j <= amount;j++){
          dp[j] += dp[j-coins[i]];
          // 或者
       dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);// 求最小值哪种遍历顺序都可以
       }
  }


或者
    	for(int i= 0;i<=target;i++ ){
            for(int j = 0 ;j < nums.length;j++){  
 //（也可能  for(int j = 1 ;j <= 2;j++){//步数要从 1 开始）--当物品时值不是数组的时候
                if(i>=nums[j]){  //等于 不能丢
                    dp[i] += dp[i-nums[j]];
                    // 或者
         	 dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);// 求最小值哪种遍历顺序都可以
                }
            }
        }

	return dp[amount]   / return  dp[amount]== amount+1 ? -1  :dp[amount]; ...
剩下的就是根据 题目 进行 数据预处理 返回值变化等 的填充
   
```

```java
特例：值得推敲
    
    
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
    
 public boolean wordBreak(String s, List<String> wordDict) {
//dp[i] : 字符串长度为i的话，dp[i]为true，表⽰可以拆分为⼀个或多个在字典中出现的单词。 
//s 是有 顺序的 所以就只能 先背包再物品  --- 排列
    int n = s.length();
    boolean dp[] = new boolean [n+1];
    dp[0] = true;//其实无意义
// i = 1 原因是字符串时非空的
  for(int i= 1; i<= n;i++){   //背包
    for(int j=0; j<i ;j++){  //其是在字符串里面截取的，所以要小于i
       //只要确定dp[j]是true,dp[j]前面j段距离是true 
        //并且[j, i]这个区间的子串出现在字典里，那么dp[i]一定是true
      //每次构造字符串是到不了i的，因此dp[j]看成是到j-1的字符,所以写成s.substring(j,i)<表示截取字符串j-i段>,而不是s.substring(j+1,i) 
     // 0              j      i
     // ----------------------------
         if(wordDict.contains(s.substring(j,i)) && dp[j]){
             dp[i] =  true;
             }
        }
    }
    return dp[n];
}

```

### 子序列问题：

>- 子数组、子序列这类问题，你就可以尝试定义 `dp[i]` 是以 `nums[i]` 为结尾的最大子数组和/最长递增子序列，因为这样定义更容易将 `dp[i+1]` 和 `dp[i]` 建立起联系，利用数学归纳法写出状态转移方程
>
>- **对于两个字符串求子序列的问题，都是用两个指针`i`和`j`分别在两个字符串上移动，大概率是动态规划思路**。
>
>- 子序列和最值几乎都是动态规划技巧

- 思路一： 一维dp数组

  dp[i] 是一个以  nums[i]/array[i]  为结尾的最长递增子序列的长度（符合归纳法）

```java
  int  n= array.length;
  int []dp =new int[n];
  for(int i=1,i<=n;i++)
      for(int j=0;j<=i;j++)
          dp[i] = max(dp[i],dp[j]+1) /  最值 {dp......}
  
```

- 思路二：二维数组

  两个字符串、数组    的子序列

    - 数组arr1 []  数组arr2[] 中需求的子序列(最值 子序列 )  的长度dp[i]\[j]  —  涉及两个子序列
    - 数组arr1 [] 需求的子序列(最值 子序列 ) 的长度dp[i]\[j]                       — 设计一个子序列

``` java
int m =arr1.length;
int n = arr2.length;
int [][]dp= new int[m][n];
  for(int i=1,i<=m;i++)
      for(int j=0;j<=n;j++)
			dp[i] = dp[i-1][j-1]    /  最值 {dp......}
```

> - 子序列是可以不连续的，也可以连续的，
>
> ​		连续的子序列之和前一个元素的状态相关，不连续的和前面0-i-1  的状态相关
>
> - 子串子数组是连续的

#### 数组子序列中的一维dp（数组）

###### 1、确定dp[]的含义

>==问什么设什么== 但是 大多数情况之下要判断比较取dp[] 中的最大值
>
>```java
>比如：
>for (int i = 0; i < nums.length; i++){
>   ......
>	if (dp[i + 1] > result) 
>       	result = dp[i + 1];
>}
>	return result;
>```
>
>如：
>
>​	**dp[i]**：表⽰以下标**i**为结尾的数组的  最长上升子序列长度为dp[i]  （问的是长度）
>
>​	**dp[i]**：表⽰以下标**i**为结尾的数组的  连续递增的⼦序列长度为**dp[i]** （问的是长度）
>
>​	**dp[i]**：表⽰以下标**i**为结尾的数组的   最⼤连续⼦序列和为**dp[i]**（问的是和）

###### 2、选择  –状态转移方程

>判断：是连续的子序列还是不连续的子序列
>
>​		连续的子序列之和前一个元素的状态相关，不连续的和前面`  0~i-1 ` 的状态相关
>
>如:==不连续==
>
>```java
>if (nums[i] > nums[j]) {
>	dp[i] = max(dp[i], dp[j] + 1);   // 最长递增子序列
>}
>```
>
>==连续==
>
>```java
>dp[i] = max(dp[i - 1] + nums[i], nums[i]);   //与前一个元素  i-1 相关  最大子数组和
>
>
>//或者
>
>if(nums[i-1] < nums[i]){    //与前一个元素  i-1 相关    最长递增子数组
>  dp[i]= dp[i-1]+1;
>}  
>
>```

###### 3、确定初始值

>`Arrays.fill(dp,1);`     //递增序列
>
>`dp[0]= nums[0]`  //子数组和

###### 4、确定遍历顺序

>一般都是  ：    前     ->       后

>==不连续：==
>
>```java
>for (int i = 0; i < nums.length; i++) {
>    for (int j = 0; j < i; j++) {//因为和前 i-1 个元素的状态相关,
>    }
>}
>```
>
>
>
>==连续：==
>
>```java
>for (int i = 1; i < nums.length; i++) {
>	// 和前一个元素有关，所以要考虑i的起始坐标
>}
>```

###### 5、打印dp数组



#### 二维dp中的 公共子序列 （两个  字符串/数组）

###### dp[]\[]含义

> 公共子序列问题中的`dp[i][j]`定义都是：
>
> ​	`以长度为[0, i - 1]的 字符串1/ 数组1 ，和长度为[0, j - 1]的 字符串2/数组2，`
>
> ​			`的公共子序列长度为dp[i][j]`

###### 状态转移方程

> 数组会有连续和不连续的区别
>
> ==数组和字符串在不连续的时候是一样的==

>==连续时==
>
>​		**只讨论当数组值相等的时候**
>
>```java
>if(nums1[i-1] == nums2[j-1]){
>  dp[i][j] = dp[i-1][j-1]+1;
>}
>```
>
>==不连续时==
>
>​		**数组值相等和不等的时候都要讨论**
>
>```java
>if(text1.charAt(i-1) == text2.charAt(j-1))/ if(nums1[i-1] == nums2[j-1])
>dp[i][j] =  dp[i-1][j-1] +1;
>else 
>dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
>```

###### 初始值

>dp表都是空的，维度是`  i+1，j+1`，
>
>第一列 和 第一行 都是全 0的，然后行列都是从 1  开始 判断 填写

###### 遍历顺序

>无论是数组还是字符串都是==一样的==
>
>```java
>for(int i= 1; i<=nums1.length;i++) {
>   for(int j = 1 ;j<= nums2.length;j++){
>          ...
>        System.out.print(dp[i][j]);  //打印dp数组
>   }
>}
>```

###### 打印dp数组



#### 二维dp中  对子序列操作（字符串）

###### 1、dp[]\[]数组定义

>`dp[i][j] 表⽰以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同⼦序列的长度 为dp[i][j]`
>
>
>
>`dp[i][j]表⽰以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]`

###### 2、选择:状态转移方程

>同样的：分为相等和不相等两种情况；
>
>==相等== ` if(s.charAt(i-1) == t.charAt(j-1)){...}`
>
>**只允许操作（删除、 增加）一个字符串时 **   ==求个数==
>
>```java
>dp[i][j] = dp[i-1][j-1] +1;  ---判断是否是子序列    求子序列个数
>
>dp[i][j] = dp[i-1][j]+dp[i-1][j-1]; --- s 的子序列中 t 出现的个数
>```
>
>**操作（删除、 增加）两个字符串时  **    ==求操作次数==
>
>```java
>dp[i][j] = dp[i-1][j-1];  -- 最小操作个数不要加 1 
>```
>
>**操作两个字符串（增、删、替换）**==求操作次数==
>
>```java
>dp[i][j] = dp[i-1][j-1];  -- 最小操作个数不要加 1 
>```
>
>
>
>==不相等== `else`
>
>**只允许操作（删除、添加）一个字符串时**      ==求个数==
>
>```java
>dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);      --- 判断是否是子序列   求子序列个数
>
>dp[i][j]=dp[i-1][j];       --- s 的子序列中 t 出现的个数
>```
>
>**操作（删除、 增加）两个字符串时**       ==求操作次数==
>
>```java
>dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1)
><=>  dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1])+ 1
>```
>
>**操作两个字符串（增、删、替换）**         ==求操作次数==
>
>```java
>dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j], dp[i][j - 1]) + 1);
>	//区别： 1、这里替换 是 +1 两个都不一样的时候，替换操作 +1;但是 删除 +2； 所以选择替换才是最少的操作次数
><=>  dp[i][j] = Math.min(dp[i - 1][j - 1],dp[i - 1][j], dp[i][j - 1]) + 1;
>	//2、这里不能简化   而且因为 java 原因还要 写 一个 min（） 方法；
>```



###### 3、初始化

>根据题目设定，比如
>
>要是问 操作距离
>
>```java
>for(int i = 1;i<=s1.length/s1.length();i++){
>	dp[i][0] = i;
>}
>for(int j = 1;j<= s2.length/s2.length();j++){
>	dp[0][j] = j;
>}
>
>或者
>dp[0][0] = 0;
>```
>
>要是问 有包含多少子序列
>
>```java
>for(int i=0;i<=s1.length();i++){    //子序列所在的列/行  一行全为 1
>dp[i][0]=1;
>}    //因为空集是所有字符串子集, 所以我们第一行都是 1
>```
>
>否则一般还是设为 全0

###### 4、遍历顺序

>一般都是：
>
>```java
>for(int i=1;i<=s1.length /s1.length() ;i++){
>for(int j=1;j<=s2.length / s2.length();j++){
>  }          
>}
>```
>
>也可以由递推公式进行  画图 判断

###### 5、打印数组

```java
		for (int i = 0; i<=s1.length /s1.length(); i++) {
            for (int j = 0; i<=s2.length /s2.length(); j++) {
                System.out.print(dp[i][j]);
            }
             System.out.println();
        }
```

#### 二维dp中 回文串（字符串）

###### 1、dp[]\[]数组的定义

>`dp[i][j]：字符串s在[i, j]范围内最长的回⽂⼦序列的长度为dp[i][j]`
>
>此时的区间是` i，j ` 不再是两个字符串时候的` i-1  j-1 `了

###### 2、选择:状态转移方程

>==相等==`if(s.charAt(i) == s.charAt(j))`        ==此处是 i 和 j 了 ，不再是  i-1，j-1  了==
>
>```java
>dp[i][j] = dp[i+1][j-1]+2;
>```
>
>==不相等==
>
>```java
>dp[i][j] =Math.max(dp[i+1][j],dp[i][j-1]);
>```

###### 3、初始化

>看题目，不过一般来说回文串的`对角线都是  1 `
>
>即：
>
>```java
>for(int  j =0 ;j<n;j++){
>  	dp[j][j] =1;
>}
>```

###### 4、遍历顺序

>集体看题目和自己推导
>
>一般为： 自下向上    自左向右
>
>如：
>
>```java
>for(int i=s.length()-2;i>= 0;i--){
>  for(int j= i+1 ;j<n;j++){
>     ......        
>  }
>}
>```
>
>

###### 5、打印dp数组

```java
516. 最长回文子序列

		int n = s.length();
        int [][]dp = new int [n+1][n+1];

        for(int i = 0;i < n;i++){
             dp[i][i] =1;
        }
        for(int i=n-2;i>= 0;i--){                        ----对角线已经初始化  n-2
            for(int j=i+1;j<n;j++){
                if(s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]+2;
                }else{
                    dp[i][j] =Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        //想要得到的就是一个 字符串  起止 坐标
        return dp[0][n-1];      
    }



1312. 让字符串成为回文串的最少插入次数--------类似 编辑距离的操作

        //间接  总长度 减去 最长回文子串
        int n = s.length();
        int dp[][] = new  int [n+1][n+1];

        for(int i=0;i<n;i++){
            //间接
            //dp[i][i] =  1;
            //直接
            dp[i][i] = 0;

        }
//间接
//for(int i = n-2;i >= 0;i--){                      对角线已经初始化   n-2
        for(int i = n-1;i >= 0;i--){             ----对角线未初始化   n-1
            for(int j = i+1;j < n;j++){
                if(s.charAt(i) == s.charAt(j)){
                    //间接
                   //dp[i][j] = dp[i+1][j-1]+2;
                   //直接
                   dp[i][j]= dp[i+1][j-1];
                }else
                {    //间接
                    //dp[i][j]  = Math.max(dp[i][j-1],dp[i+1][j]);
                    //直接
                    dp[i][j]  = Math.min(dp[i][j-1],dp[i+1][j])+1;
                }
            }
        }
        //System.out.println(dp[0][n-1]);
         //间接
        //return n- dp[0][n-1];
        //直接
        return  dp[0][n-1];





647. 回⽂⼦串

dp[i][j]：表⽰区间范围[i,j] （注意是左闭右闭）的⼦串是否是回⽂⼦串，如果是dp[i][j]为true，否则为false
    
  boolean dp[][] = new boolean [s.length()+1][s.length()+1];
        int res = 0;
		int  n = s.length()
        for(int i =n-1;i>=0;i--){                    --对角线未初始化   n-1
            for(int j = i;j < n;j++){          	--对角线未初始化   所以从对角线开始
                if(s.charAt(i) == s.charAt(j)){
                    if(i==j || (j-i)==1){   //左右相邻 或者 指向的是同一个字符的时候
                        dp[i][j] = true;     
                        res++;
                   }else if (dp[i+1][j-1] == true){
                        res++;
                        dp[i][j] = true;
                    }
                }
                System.out.print(dp[i][j]);
            }
            System.out.println();
        }
        return res;
    }
    


```

### 打家劫舍问题

##### I

###### 1、dp数组定义：`考虑下标i(包括i)以内的房屋，最多可以偷窃的⾦额为dp[i]`

###### 2、选择：状态转移方程

> 偷 不偷

```java
dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
```

###### 3、初始值

```java
dp[0] = nums[0];
if(nums.length >1)    dp[1]=Math.max(nums[0],nums[1]);
```

###### 4、 遍历顺序

```java
for(int  i = 2 ;i < nums.length ;i++){
}
```

###### 5、打印dp数组

##### II

>==将  环  拆开==
>
>与 I 雷同，区别是
>
>
>
>学到了一个java内置函数
>
>```java
>int [] rob1 = Arrays.copyOfRange(nums, 0, nums.length - 1);
>int [] rob2 = Arrays.copyOfRange(nums, 1, nums.length);
>// 将0 ~ nums.length-1 的 你们是数组的值赋值给 rob     -- 将环拆开的方法
>```
>
>还有就是在主函数中调用I中函数之前要 排除特例
>
>```java
>if(nums.length == 1)  return nums[0];
>```

##### III

>对于树的话，⾸先就要想到遍历⽅式，前中后序（深度优先搜索）还是层序遍历（⼴度优先搜索）
>
>**偏重在递归和树的遍历上**
>
>```java
>public int rob(TreeNode root) {
>
>int robtreeres[] = robtree(root);
>
>return Math.max(robtreeres[0],robtreeres[1]);
>
>}
>
>public int[] robtree(TreeNode root) {
>//对于以r.left为根的树，计算抢劫根节点(r.left)与不抢劫根节点可获得最大金额. 
>//left[0]则为不抢r.left可获得的最大金额,
>//left[1]则为抢劫r.left可获得的最大金额 
>if(root  == null)    return new int [2];
>//递归遍历
>int leftdp [] =robtree(root.left);
>//right[] 分析同理
>int rightdp [] =robtree(root.right) ;
>
>int val1 =  root.val+leftdp[1]+rightdp[1];  //父节点偷，子节点只能不偷   1 表示不偷   0 表示偷
>
>//父节点不偷，子节点既能偷也能不偷
>int val2 = Math.max(leftdp[0] ,leftdp[1])+ Math.max(rightdp[0],rightdp[1]);
>
>
>return new int[]{val1,val2};
>}
>```



### 树形dp

#### ACM形式全方位学习

##### 介绍

树形dp的主要实现形式是`𝑑𝑓𝑠`，在`𝑑𝑓𝑠`中`𝑑𝑝`主要的实现形式是`𝑑𝑝[𝑖][𝑗][0/1]`

`𝑖`是以`𝑖`为`根`的子树，`𝑗`是表示在以`𝑖为根的子树`中选择`𝑗个子节点`，0表示这个节点`不选`，1表示选择这个`节点`。有的时候`𝑗`或`0/1`这`一维可以压掉`

##### 核心dp方程

>##### 选择节点类
>
>​	  `dp[i][0] = dp[j][1]`
>
>​     `dp[i][1]=max/min(dp[j][0],dp[j][1])`
>
>##### 树形背包类
>
>​     `𝑑𝑝[𝑣][𝑘]=𝑑𝑝[𝑢][𝑘]+𝑣𝑎𝑙`
>
>​    `𝑑𝑝[𝑢][𝑘]=𝑚𝑎𝑥(𝑑𝑝[𝑢][𝑘],𝑑𝑝[𝑣][𝑘−1])`

##### ACM输入格式

<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304131133326.png" alt="image-20230413113306286" style="zoom:25%;" />



>```java
>// mian 中 进行 dfs  以及输入输出
>public static void main(String[] args) {
>
>   Scanner scanner = new Scanner(System.in);
>   //第一段数字
>   int n = scanner.nextInt();
>   //第二段数字
>   for(int i = 1;i<= n;i++){
>       value[i]= scanner.nextInt();
>   }
>
>	// 邻接表  的预处理
>   for (int i = 1;i<= n;i++){
>       tree[i] = new ArrayList<>();
>   }
>
>
>   // 第三段数字
>   for(int i = 1;i<= n -1;i++){
>       int child = scanner.nextInt();
>       int father = scanner.nextInt();
>
>       // 将节点 father 的一个子节点 child 加入到 son[k] 中
>       tree[father].add(child);
>
>       // 标志位1 就不能是子节点了
>       not_root[child] = 1;
>   }
>
>//        for (int i = 0; i <= n; i++) {
>//            System.out.println(tree[i]);
>//        }
>
>   int root = 0;
>   for (int i = 1; i <= n; i++) {
>       if(not_root[i] == 0){
>           root = i;
>           break;
>       }
>   }
>   dfs(root);
>   System.out.println(Math.max(dp[root][0],dp[root][1]));
>}
>
>
>
>
>
>///////////////////////
>
>//说明： 
>ArrayList的存储结构
>// 执行：
>List<Integer>[] tree = new List[n + 1];
>for (int i = 1; i <= n; i++) {
>tree[i] = new ArrayList<>();
>}
>
>
>//实际的add操作就是执行了：
>tree[3].add(1);
>tree[3].add(2);
>tree[4].add(6);
>tree[4].add(7);
>tree[5].add(4);
>tree[5].add(3);
>
>
>for (int i = 0; i <= n; i++) {
>System.out.println("tree["+i+"]"+tree[i]);
>}
>
>//即可得到各个节点对应的子节点。
>tree[0]null
>tree[1][]
>tree[2][]
>tree[3][1, 2]
>tree[4][6, 7]
>tree[5][4, 3]
>tree[6][]
>tree[7][]
>```
>
>```java
>// 数据定义
>	static final int MAX_Length = 6005;（6005看题目要求而来）
>static int value[]= new int[MAX_Length];
>static int dp[][] = new int[MAX_Length][2];
>// 判断是否为根
>static int not_root[] = new int[MAX_Length];
>// 使用 邻接表 进行存储 父子节点 这要是 List
>static List<Integer>[] tree = new ArrayList[MAX_Length];
>
>```
>
>```java
>// 进行dp  要注意的是  先找到 子节点在 数组数组链表中的位置
>
>	static void dfs(int root) {
>   dp[root][0] = 0;
>   dp[root][1] = value[root];
>   //找子树
>      for (int i = 0; i < tree[root].size(); i++) {
>          //因为dp函数是要进行寻找到子节点的
>          int son = tree[root].get(i);
>          dfs(son);
>          // 父亲去 孩子就不能去
>          dp[root][1] += dp[son][0];
>          // 父亲不去，孩子就能去，但是去不去是取 最大值的
>          dp[root][0] += Math.max(dp[son][0],dp[son][1]);
>  }
>}
>```











### 股票问题

>==选择：==
>		买入、卖出、无操作
>
>==状态==
>
>​		第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（用 1 表示持有，0 表示没有持有）

>基本的==状态转移方程==：
>
>n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
>
>`dp[i][k][0] = max(dp[i-1][k][0]      ,     dp[i-1][k][1] + prices[i])`
>
>​		一直保持没有持有股票的状态，买的次数还是k       今天刚刚卖掉，但是前一天还是持有股票的状态,但是买的次数还是k
>
>`dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`
>
>​		一直保持持有股票的状态，买的次数还是k          今天刚刚买了，但是之前一直没有持有股票的状态,买的次数是k-1
>
>**ps:状态 `k` 的定义并不是「已进行的交易次数」，而是「最大购买交易的上限」**

>==初始化==
>
>`dp[-1][...][0] = dp[...][0][0] = 0 `       没有股票  所以价值肯定是 0
>
>`dp[-1][...][1] = dp[...][0][1] = -infinity`      购买次数 为 0  或者天数为 <0  此时还有票 显然非法

>具体题目：
>
>- k 为固定值 即：指定的购买次数  <`dp[i-1][0][0] = 0`>
>
>​		此时方程为：
>
>​				`dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) `
>
>​				`dp[i][1] = max(dp[i-1][1], -prices[i])`
>
>​				特殊处理
>
>```java
>if (i - 1 < 0){
> dp[i][0] = 0;
> // 根据状态转移方程可得：
> //   dp[i][0] 
> // = max(dp[-1][0], dp[-1][1] + prices[i])
> // = max(0, -infinity + prices[i]) = 0
>
> dp[i][1] = -prices[i];
> // 根据状态转移方程可得：
> //   dp[i][1] 
> // = max(dp[-1][1], dp[-1][0] - prices[i])
> // = max(-infinity, 0 - prices[i]) 
> // = -prices[i]
> continue;
>}
>
>
>
>// 按五部曲来
>或者直接进行初始化，在for 循环之外
>   dp[0][0] = 0;
>   dp[0][1] = -prices[0];
>//随后 for循环内就不要进行判断了
>```
>
>- k为 无穷大
>
>​		此时方程为：
>
>​				`dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) `
>
>​				`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`
>
>​		特殊处理和上面一样
>
>-  k 为  无穷大 且 含有手续费
>
> ​	此时方程为：
>
>  ​				`dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) `
>
>  ​				`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]-fee)`
>
> ​	特殊处理和上面类似 `dp[i][1] = -prices[i]-fee;`  /或者=>(单独初始化)/`dp[0][1] = -prices[0]-fee;`
>
>- k 为  无穷大 且 存在==冷冻期==（初始化的特例）
>
> ​		此时方程为：
>
>  ​				`dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) `
>
>  ​				`dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])`
>
> ​		特殊处理：
>
> ```java
> // base case 1
> dp[0][0] = 0;
> dp[0][1] = -prices[0];
>
> 		for 循环中
>              if (i - 2 < 0) {
>                 // base case 2
>                 dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
>                 // i - 2 小于 0 时根据状态转移方程推出对应 base case
>                 dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
>                 //   dp[i][1] 
>                 // = max(dp[i-1][1], dp[-1][0] - prices[i])
>                 // = max(dp[i-1][1], 0 - prices[i])
>                 // = max(dp[i-1][1], -prices[i])
>                 continue;
>         	}
> // 写在for 循环内是不需要进行n==1 的判断的
> 所以另一种写法，就是将i 从2 开始遍历，那么 basecase 就在循环外定义  循环内无判断的操作
> 即： 
>     		if(n == 1) return 0; //有冷冻期 
>             if(n<0)  return 0;
>             int dp[][] = new int [n][2];
>             dp[0][0] = 0;
>             dp[0][1] = -prices[0];
>             dp[1][0]= Math.max(dp[0][0],dp[0][1]+prices[1]);
>             dp[1][1]= Math.max(dp[0][1],-prices[1]);
> ```
>
>- k 为最多（固定值）次
   >
   >  此时方程为：
>
>​              `dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) `
>
>​              `dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`
>
>  	特殊处理和上面一样  `for 循环嵌套处理 basecase`
>
>​	   此处需要嵌套循环，`多加一个 对 K 要进行穷举的循环`
>
>```java
>public int maxProfit(int[] prices) {
>       int mk = 2;
>       int n = prices.length;
>       int dp[][][] = new int[n][mk+1][2];
>
>       for(int k = mk;k>0;k--){
>           dp[0][k][0] = 0;
>           dp[0][k][1] = -prices[0];
>       }
>
>        for(int i = 1;i < n;i++){
>            for(int k= mk;k > 0;k--){
>               dp[i][k][0] = Math.max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]);
>               dp[i][k][1] = Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]);
>            }
>        }
>        return dp[n-1][mk][0];
>   }
>
>
>另一种解法：<或者直接使用下面的一题的模板>
>   	 public int maxProfit(int[] prices) {
>       int n  =prices.length;
>       int dp[][] = new int [n][5];
>       dp[0][0] =  0;
>       dp[0][1] =  -prices[0];
>       dp[0][2] = 0;
>       dp[0][3] =  -prices[0];
>       dp[0][4] =  0;
>       for(int i = 1;i<n;i++){
>           // 套娃操作
>           dp[i][0] = dp[i-1][0];  //不操作   可删
>           dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);    // 买一次
>           dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);    //卖一次
>           dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);    // 再买一次
>           dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);    // 再卖一次
>       }
>       return dp[n-1][4];  // 最后一次状态是4
>}
>```
>
>
>
>- k 为最多（非固定值）次
>
>​	此时和上面 固定次数类似 只是需要对 k 进行缩小
>
>```java
> if (max_k > n / 2) {
>        // 复用之前交易次数 k 没有限制的情况
>        return maxProfit_k_inf(prices);
> }
>```
>
>```java
>public int maxProfit(int k, int[] prices) {
>           int  n  =prices.length;
>           if(n==0) return 0;
>           if(k> n/2) return maxProfitone(prices);   //递归  不进行递归调用也能通过
>           int dp [][][] = new int [n][k+1][2];
>
>       for(int  i = 0;i<n;i++){
>          for(int j =k;j>0; j--){
>              if(i-1<0){
>                  dp[i][j][0] = 0;
>                  dp[i][j][1] = -prices[i];
>                  continue;
>              }
>              dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);
>              dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);
>          }
>       }
>       return dp[n-1][k][0];
>   }
>   int maxProfitone( int[] prices) {
>       int n = prices.length;
>       int dp[][]= new int [n][2];
>       dp[0][0]= 0;
>       dp[0][1] = -prices[0];
>       for(int i=1;i<n;i++){
>           dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
>           dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
>       }
>       return dp[n-1][0];
>   }
>
>解法优化：<代码减少>
>       public int maxProfit(int k, int[] prices) {
>           int  n  =prices.length;
>           if(n==0) return 0;
>           int dp [][][] = new int [n][k+1][2];
>   // basecase 
>       for (int i = 0; i <= k; i++) {
>           dp[0][i][1] = -prices[0];
>       }
>       for(int  i = 1;i<n;i++){
>          for(int j =k;j>0; j--){
>              dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);
>              dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);
>          }
>       }
>       return dp[n-1][k][0];
>   }
>
>
>另一种解法<上面一题的模版>
>     public int maxProfit(int k, int[] prices) {
>           int  n  =prices.length;
>           if(n==0) return 0;
>           int dp [][] = new int [n][2*k+1];
>           dp[0][0] =0;
>
>           for(int j=0;j<2*k;j+=2){
>               dp[0][j+1]= -prices[0];
>           }
>
>           for(int i = 1;i<n;i++){
>               for(int j=0;j<2*k;j+=2){
>                   dp[i][j+1]= Math.max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
>                   dp[i][j+2]= Math.max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
>               }
>           }
>           return dp[n-1][2*k];
>   }
>```

>最终答案：求的是 最终答案是 `dp[n - 1][K][0]`

###### 万里归一：全能答案<不考虑时间空间复杂度>

>**Q:**股票价格数组 `prices`，你最多进行 `max_k` 次交易，每次交易需要额外消耗 `fee` 的手续费，而且每次交易之后需要经过 `cooldown` 天的冷冻期才能进行下一次交易，请你计算并返回可以获得的最大利润。
>
>**A:**` int maxProfit_all_in_one(int max_k, int[] prices, int cooldown, int fee);`
>
>```java
>public int maxProfit_all_in_one(int max_k, int[] prices, int cooldown, int fee) {
>
>   int n = prices.length;
>   int dp[][][] = new int[n][max_k][2];
>   if(n<0) return 0;
>// 递归  k 为最多（非固定值）次
>   if(max_k>n/2) return maxProfit_k_inf(prices, cooldown, fee); 
>// 递归  k 为最多（非固定值）次
>   for(int i=0; i<n; i++){                  
>       dp[i][0][1] = Integer.MIN_VALUE;
>       dp[i][0][0] = 0;
>   }
>
>   for(int i=0; i<n; i++){
>       // 递归  k 为最多（非固定值）次
>       for(int k = max_k; k>0; k--) {
>           if (i - 1 == -1) {
>               dp[i][k][0] = 0;
>               dp[i][k][1] = -prices[i] - fee;
>               continue;
>           }
>           //存在冷冻期
>           if (i - cooldown - 1 < 0) {
>               dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
>               dp[i][k][1] = Math.max(dp[i - 1][k][1], -prices[i] - fee);
>               continue;
>           }
>				// k 为最多（非固定值）次
>           dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
>           //存在冷冻期    含有手续费
>           dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - cooldown - 1][k - 1][0] - prices[i] - fee);
>       }
>   }
>   return dp[n-1][max_k][0];
>}
>
>private int maxProfit_k_inf(int[] prices, int cooldown, int fee) {
>   int n = prices.length;
>   int dp[][]= new int[n][2];
>   for(int i = 0;i<n;i++){
>       if(i-1 == -1){
>           dp[i][0] = 0;
>           dp[i][1] = -prices[i]-fee;
>           continue;
>       }
>      //存在冷冻期    含有手续费
>       if(i-1-cooldown < 0){
>           dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);;
>           dp[i][1] = Math.max(dp[i - 1][1], -prices[i] - fee);
>           continue;
>       }
>
>       dp[i][0] = Math.max(dp[i - 1][0], dp[i-1][1]+prices[i]);
>        //存在冷冻期    含有手续费
>       dp[i][1] = Math.max(dp[i - 1][1], dp[i-cooldown-1][0]-prices[i]-fee);
>   }
>   return  dp[n-1][0];
>}
>```

### 玩游戏专题

##### 路径问题

```java
// 基本的路径： 最小路径和
    public int minPathSum(int[][] grid) {
            int  m = grid.length;
            int n = grid[0].length;
        int dp [][] =new int [m+1][n+1];
       // dp[][] =min(dp[i][j-1],dp[i-1][j])+grid[i][j];

       //初始化：
        dp[0][0]=grid[0][0];
        for(int  i =1;i<m;i++){
            dp[i][0] = dp[i-1][0]+grid[i][0]; 
        } 
        for(int  i =1;i<n;i++){
            dp[0][i]= dp[0][i-1]+grid[0][i]; 
        } 
       
        
       for(int i = 1;i<m;i++){
           for(int j = 1;j< n;j++){
               dp[i][j] =Math.min(dp[i][j-1],dp[i-1][j])+grid[i][j];
           }
       }
       return dp[m-1][n-1];

    }


//解救公主  ： 上述问题的 倒序
 public int calculateMinimumHP(int[][] dungeon) {
        // 最小路径 逆向思维

        int m = dungeon.length;
        int n = dungeon[0].length;
        int dp[][] = new int [m][n];

        //设置左下角的值
        dp[m-1][n-1]= Math.max(0, -dungeon[m-1][n-1]);
        // 设置最后一列
        for(int i = m-2;i>=0;i--){
            dp[i][n-1] = dp[i+1][n-1] - dungeon[i][n-1];
            dp[i][n-1] = Math.max(dp[i][n-1],0);
        }
        // 设置最后一行
        for(int i = n-2;i>=0;i--){
            dp[m-1][i] = dp[m-1][i+1]  -  dungeon[m-1][i];
            dp[m-1][i] = Math.max(dp[m-1][i],0);
        }

        for(int  i=m-2;i>=0;i--){
            for(int  j = n-2;j>=0;j--){
                dp[i][j] = Math.min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];
                dp[i][j] = Math.max(0,dp[i][j]);
            }
        }
        return dp[0][0]+1;
    }

// 中转站  min消费
public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        //k+1+1 的原因是 将最后一个节点也理解成中转节点  或者理解为 k+1个边
        int dp[][] = new int [k+2][n];
        // 找最小，所以全都初始化为 不可达
        for(int i = 0;i< dp.length;i++){
            Arrays.fill(dp[i],Integer.MAX_VALUE-10000);
        }
        // for(int []flight :flights){
        //     if(flight[0] == src)  dp[0][flight[1]] = flight[2];
        // }
        //无论几次，从出发点到出发点总是花费为0
        for(int i = 0 ; i < dp.length ; i++){
            dp[i][src] = 0;
        }
        for(int  i =1;i<dp.length;i++){
            for(int []flight :flights){
               int from = flight[0];
               int to = flight[1];
               int cost = flight[2];
               dp[i][to]=Math.min(dp[i][to],dp[i-1][from]+cost);
            }
        }
       
        return dp[k+1][dst] == Integer.MAX_VALUE-10000? -1:dp[k+1][dst];
    }
```



## 回溯

#### ==本质：==

>- for 循环里面嵌套递归    以实现   n 个 for 循环
> - 就是 **其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**
>
>- 解决一个回溯问题，实际上就是一个决策树的遍历过程



####  解决的问题：

>- 组合问题：N个数里面按一定规则找出k个数的集合
>- 子集问题：一个N个数的集合里有多少符合条件的子集
>- 排列问题：N个数按一定规则全排列，有几种排列方式
>- 切割问题：一个字符串按一定规则有几种切割方式
>- 棋盘问题：N皇后，解数独等等

>- **组合是不强调元素顺序的，排列是强调元素顺序**。
>
>- **组合无序    排列有序**

>- **回溯法解决的问题都可以抽象为树形结构**，指的是**所有回溯法**的问题**都可以**抽象为树形结构！
>
>- 因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。
>
>- 递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

#### 录的三步曲：

>- 回溯函数模板返回值以及参数
>
>- 回溯算法中函数返回值一般为void
>- 再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数
>
>- 回溯函数终止条件
>
>- 一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归
>
>- 回溯搜索的遍历过程
>
>- 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
>
>
>
> ```java
> 伪代码
>
> 回溯函数伪代码如下：
>     void backtracking(参数)
>
> 回溯函数终止条件伪代码
>     ```java
>     if (终止条件) {
>                存放结果;
>                return;
>        	}
> ```
>
> 回溯函数遍历过程伪代码
>    ```java
>     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
>               处理节点;
>               backtracking(路径，选择列表); // 递归
>               回溯，撤销处理结果
>           }
>    ```
>
>
>
> 回溯算法模板框架如下
>
>```java
> void backtracking(参数) {
>      if (终止条件) {
>               存放结果;
>               return;
>           }
>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
>     处理节点;
>      backtracking(路径，选择列表); // 递归
>      回溯，撤销处理结果
>  }
>}
>
>```

#### dong 模版

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    //for 选择 in 选择列表:
       // 做选择
       // backtrack(路径, 选择列表)
        //撤销选择

        for 选择 in 选择列表:
            // 做选择
            将该选择从选择列表移除
            路径.add(选择)
            backtrack(路径, 选择列表)
           // 撤销选择
            路径.remove(选择)
            将该选择再加入选择列表
            
1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。
```

>DFS 和  回溯 区别：
>
>- 多叉树 DFS 遍历框架的前序位置和后序位置应该在 for 循环外面，并不应该是在 for 循环里面。而溯算法中跑到 for 循环里面了
>
>动态规划 和 回溯算法 区别与联系
>
>- 动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的
>
>另外：
>
>​	当遇到选择空间的个数（桶）很多时，我们应该以每次选择的次数（球）为`trackbacking`函数的for核心，也就是说：
>
>我们应该尽量「少量多次」，就是说宁可多做几次选择（乘法关系），也不要给太大的选择空间（指数关系）；做 `n` 次「`k` 选一」仅重复一次（`O(k^n)`），比 `n` 次「二选一」重复 `k` 次（`O(k*2^n)`）效率低很多。
>
>```java
>for (int i = start; i < nums.length; i++) {} // nums[]是指球的个数 选择  √
>
>
>而不是：  (  也就是leetcode  698 )
>
>
>for (int i = 0; i < bucket.length; i++) {}    //bucket[] 桶的个数 不选  ×
>```



><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303221333571.png" alt="image-20230322133359518" style="zoom:25%;" />
>
>**前序遍历的代码在进入某一个节点之前的那个时间点执行**
>
>**后序遍历代码在离开某个节点之后的那个时间点执行**

>**写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。

#### 我的步骤：

> ###### 1、写出两个集合
>
> 一个用来存放符合条件单一结果
>
> ```java
> List<List<Integer>> res = new LinkedList<>();  // 记录回溯算法的递归路径
> ```
>
> 一个用来存放符合条件结果的集合
>
> ```java
> LinkedList<Integer> track = new LinkedList<>();
> ```
>
> ###### 2、书写确定了返回值 和 参数 的函数
>
> ###### 3、确定终止条件
>
> ###### 4、解决嵌套 for 循环的 递归  部分

#### 子集、组合、排列整合

##### 分类

>1、**元素不可以重复**，**最多选一次**
>
>2、**元素可以重复**，**最多选一次**
>
>3、**元素不可以重复**，**可以选 n 次**

##### 记住两张图

<img src="https://labuladong.gitee.io/algo/images/排列组合/2.jpeg" alt="img" style="zoom:20%;" />                      <img src="https://labuladong.gitee.io/algo/images/排列组合/1.jpeg" alt="img" style="zoom:20%;" />     



>**首先，组合问题和子集问题其实是等价的，这个后面会讲；至于之前说的三种变化形式，无非是在这两棵树上剪掉或者增加一些树枝罢了**

>==前置==
>
>```java
>// 记录回溯算法的结果集
>List<List<Integer>> res = new LinkedList<>();
>// 记录回溯算法的递归路径
>LinkedList<Integer> track = new LinkedList<>();
>```
>
>

###### **1、元素不可以重复**，**最多选一次**

>==公共部分==
>
>```java
>	 // 主函数
>public List<List<Integer>> .....(......) {
>
>   backtrack(........);
>
>   return res;
>}
>
>// 回溯算法核心函数，遍历子集问题的回溯树
>void backtrack(.......) {
>
>  //终止条件
>
>   // 回溯算法标准框架
>   for (.......) {
>       // 做选择
>       track.addLast(nums[i]  /  i);
>       // 递归
>       backtrack(......);  
>       // 撤销选择    
>       track.removeLast();
>   }
>}
>```
>
>**子集|组合中**：
>
>使用 `start` 变量保证元素 `nums[start]` 之后只会出现 `nums[start+1..]` 中的元素，通过固定元素的相对位置保证不出现重复的子集
>
>**排列中**：
>
>额外使用 `used` 数组来标记哪些元素还可以被选择。
>
>==子集==
>
>```java
>主函数:
>	int start = 0;
>	backtracking(nums,start);
>
>回溯函数:
>// 加入集合
>	result.add(new LinkedList<>(track));
>// 核心   i 从start 开始
>	for (int i = startIndex; i < nums.length; i++) {
>// 做选择
>       track.addLast(nums[i]);
>//递归
>       backtracking(nums,i+1);
>//撤销选择   
>       track.removeLast();
>   }
>   return;
>```
>
>
>
>==组合==
>
>```java
>主函数:
>	int start = 1;     //// 因为这里的数组是从 1 开始 所以也将元素下标从1 开始
>backtracking(start,k,n);
>return res;
>
>回溯函数:
>// 加入集合
>		if(track.size() == k ){
>       res.add(new LinkedList<>(track));
>       return;
>   }
>// 核心   i 从start 开始
>	for(int i = start;i<= n;i++){
>// 做选择
>       track.addLast(i);
>//递归
>       backtracking(i+1,k,n);
>//撤销选择   
>       track.removeLast();
>   }
>   return; 
>```
>
>==组合总和III==
>
>```java
>int sum = 0;
>主函数:
>	int nums[] = {1,2,3,4,5,6,7,8,9};
>	 if(n>55)  return res;
>int start = 1;     // 因为这里的数组是从 1 开始 所以也将元素下标从 1 开始
>backtracking(nums,start,k,n);
>return res;
>
>
>回溯函数:
>// 加入集合
>if(n == sum && track.size() == k ){
>       res.add(new LinkedList<>(track));
>       return;
>   }
>// 核心   i 从start 开始
>	for(int i = start;i<= 9 ;i++){     题目要求就是 固定长度 9
>// 做选择
>       track.add(nums[i]);
>       sum += i;
>//递归
>        backtracking(nums,i+1,k,n);
>//撤销选择   
>       track.removeLast();
>       sum -= i;
>   }
>   return;
>
>```
>
>==全排列==
>
>```java
>主函数:
>if(nums.length == 0 )  return res;
>   int start = 0;
>   boolean  used[] = new boolean [nums.length];
>   backtracking(nums,used);
>   return res;
>回溯函数:
>// 加入集合
>if(track.size() == nums.length){
>       res.add(new LinkedList<>(track));
>       return ;
>  }
>// 核心 i 从start 开始
>	for(int i = 0;i<nums.length;i++){
>
>   if(used[i]) continue;    // 保证元素不重复
>
>// 做选择
>       track.add(nums[i]);
>       used[i]= true;
>//递归
>        backtracking(nums,used);
>//撤销选择   
>     track.removeLast();
>       used[i]= false;
>}
>   return;
>
>```
>
>==总结==
>
>​	其实最基本的框架都是一样的，无非就是在个基础上要 传的参数 有所区别 而需要的不同的定义有所不同罢了





###### **2、元素可以重复**，**最多选一次**

>**子集 和 排列** 本质和**1、……** 的内容是几乎没有区别的，就是添加 或者改变了几行而已
>
>排序和 for循环添加的行的  目的是：**保证相同元素在排列中的相对位置保持不变**。
>
>**排列**：
>
>**标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。
>
>==子集==
>
>```java
>主函数：
>  Arrays.sort(nums);
>for 循环：
>  if (i > start && nums[i] == nums[i - 1]) {
>      continue;
>  }
>```
>
>>组合总和 和 **1、**是有些区别
>
>==组合总和II==
>
>```java
>int targetsum = 0;
>主函数:
>   Arrays.sort(candidates);     
>   if(candidates.length == 0 )  return result;
>   int start = 0;
>   backtracking(candidates,start,target);
>   return result;
>回溯函数:
>// 加入集合
>		if(target <  targetsum)   return;
>   if(target == targetsum){
>       result.add(new LinkedList<>(track));
>       return;
>   }
>// 核心   i 从start 开始
>	for (int i = start; i < nums.length; i++) {
>       if( i>start && nums[i] == nums[i-1] ) continue;
>
>// 做选择
>        track.addLast(nums[i]);
>       targetsum += nums[i];
>//递归
>       backtracking(nums,used);
>//撤销选择   
>     	track.removeLast();
>       targetsum -= nums[i];
>}
>   return;
>
>```
>
>>其实上面的**组合总和II**  和  满足**1、**中的**非组合总和III**  的组合总和的形式也就多了两行
>
>```java
>主函数：
>Arrays.sort(candidates);  
>
>for 循环内
>if( i>start && nums[i] == nums[i-1] ) continue;
>```
>
>==全排列==
>
>```java
>主函数：
>Arrays.sort(nums);
>
>
>for 循环内
>if( i>0 && nums[i] == nums[i-1] && !used[i-1]) continue;  //!used[i-1]
>```





###### **3、元素不可以重复**，**可以选 n 次**

>和**1、….** 反着来;也就是说：
>
>**标准的子集/组合问题是如何保证不重复使用元素的**？—在于 `backtrack` 递归时输入的参数 `start`;
>
>下面只是和**1、……** 进行比较的差别
>
>==组合总和==
>
>```java
>for(.....){
>...
>backtracking(nums,i,target);
>...
>}
>```
>
>>下面为补充
>
>==子集==
>
>```java
>backtracking 函数：
>//子集个数等于三的，因为子集的个数最大才是三  所以终止条件就是等于三的时候输出
>if(track.size()  ==  candidates.length) {
>  result.add(new LinkedList<>(track));
>  return;
>}
>
>result.add(new LinkedList<>(track));  //子集个数不为 < 3的
>	for(...){
>   ....
>backtracking(candidates,i); // 实现结果 不会出现  1，2，1  和 1，1，2 的情况
>}
>```
>
>
>
>==全排列==
>
>```java
>LinkedList<List<Integer>> result = new LinkedList<>();
>LinkedList<Integer> track = new LinkedList<>();
>public List<List<Integer>> permute(int[] nums) {
>     if(nums.length == 0)  return null;
>     backtracking(nums);
>     return result;
> }
>
> private void backtracking(int[] nums) {
>     if(track.size() == nums.length) {
>         result.add(new LinkedList<>(track));
>         return;
>     }
>     for(int  i = 0 ;i< nums.length;i++) {
>         track.add(nums[i]);
>         backtracking(nums);
>         track.removeLast();
>     }
>```
>
>相比之下，**全排列**就是将  used[] 数组这一判定条件有关的代码  **全部去除**
>
>**子集**要加上 终止条件 （栈元素 大小 **等于** 元素个数），否则会 栈溢出；而且在小于 元素个数的时候也要加到栈中，



#### 棋盘问题：

###### N皇后



###### 解数独：

>**我们并不想得到所有合法的答案，只想要一个答案**
>
>只要用一个外部变量(boolean型)记录是否找到答案，找到答案后就停止继续递归即可：

#### 分割问题

```java
//93 复位IP

     List<String> res = new LinkedList<>();
    // 分成的段数
    LinkedList<String> path = new LinkedList<>();
    public List<String> restoreIpAddresses(String s) {
        backtracking(s,0);
        return  res;
    }
    void backtracking(String s, int startIndex) {
        //当已经 分为四段的时候就需要 将其对每一段进行加 . 进行分割
        if(startIndex == s.length() && path.size() == 4){
            res.add(String.join(".",path));
        }
        //短短几行回溯   
        for(int i=0;i<s.length();i++){
            // 如果不是合法字符串
            if(!isValid(s,startIndex,i)) continue;
            //是合法的
            if(path.size()>=4) break;
            // 这里是将 遍历的满足下标的子串放进path中
            path.add(s.substring(startIndex,i+1));
            backtracking(s,i+1);
            path.removeLast();
        }
    }

    //主要是判断合法性的函数
    boolean isValid(String s,int startIndex,int end){
        int length = end-startIndex+1;
        if(length<=0 || length>3) return false;
        if(length == 1 ) return true;  //不能和<=2合并
        // 排除的是startIndex 
         if(s.charAt(startIndex) == '0') return false;
         if(length <=2 ) {
            return true;
        }    
        if(Integer.parseInt(s.substring(startIndex,startIndex+length))>255)    return false;
        else return true;
    }
    

```



## 贪心

#### 贪心选择性质:

>简单说就是：
>
>每一步都做出一个局部最优的选择，最终的结果就是全局最优。
>
>注意!这是一种特殊性质，其实只有一部分问题拥有这个性质

>==注==
>
>**排序**
>
>```java
>// Arrays.sort(points,(a,b)->(a[1]-b[1]));// 可能出现溢出情况
>
>// Arrays.sort(points,Comparator.comparingInt(a->a[1]));//升序排序 解决溢出方法2  效率较低 调用内置静态方法， 效率较低
>
>Arrays.sort(points,(a,b)->{
>    if(a[1]>b[1]) return 1;
>    if(a[1]<b[1]) return -1;
>    return 0;//上述方法可能溢出 解决方法1
>});
>```
>
>**时间安排的问题，本质上讲就是区间调度问题，十有八九得排序，然后找规律来解决。**

#### 一位数组的游戏

>跳跃游戏 目标终点是 `nums.length-1`
>
>55 题：可以使用`最大跳数`作为能否到达终点的判断会更好一点

#### 二维数组的区间问题：

> <就是 线段问题；合并线段、找交集…>
>
> [区间问题合集](https://labuladong.gitee.io/algo/di-san-zha-24031/jing-dian--a94a0/yi-ge-fang-93124/) : 区间交集、区间并集、区间覆盖这几个问题。

##### 做法：

>==1、排序==
>
>常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。
>
>==2、画图==
>
>就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。

**区间问题肯定按照区间的起点或者终点进行排序**

```java
//排序代码：
     Arrays.sort(intervals, (a, b) -> {
            // 对 起点 进行升序排序
            if(a[0]>b[0]) return 1;
            if(a[0]<b[0]) return -1;
            // 对 终点 进行降序排序
            return b[1] - a[1];
        });
//打印排序之后的代码
      for (int i = 0; i < intervals.length; i++) {
                for (int j = 0; j < intervals[i].length; j++) {
                    System.out.print(intervals[i][j] + " ");
                }
                System.out.println();
        } 
```

##### 问题分类：

###### 求重叠区间个数一类题：

```java
		//定义初始时的变量
        int res = 0   / 1;
        for(int  i =1 ;i<intervals.length;i++){
            if(intervals[i][0]< intervals[i-1][1]){
                // 取 最小 右侧并集
                intervals[i][1] = Math.min(intervals[i][1],intervals[i-1][1]);
                res++;
            }  
        }

```

###### 求完全覆盖一类题

>==需要分类讨论==

```java
// 分为三种情况
        //覆盖、相交、不相交
        //定义初始时的变量
        int res = 0;
        int left = intervals[0][0];
        int right = intervals[0][1];
        for(int i = 1;i<intervals.length;i++){
//完全覆盖时覆盖
        if(left<= intervals[i][0] &&  right >= intervals[i][1]){
            res ++ ;
        }

//相交，取最大 右侧并集
            if(right>=intervals[i][0]){
                right = Math.max(right,intervals[i][1]);
            }

//不相交
            if(right < intervals[i][0]){
                left = intervals[i][0];
                right=intervals[i][1];
            }
```

###### 求合并（并集）类题

```java
LinkedList<int[]> result =  new LinkedList<>();
        // 将结果集存放排好序之后的第一个元素
result.add(intervals[0]);

for(int i =1;i< intervals.length;i++){
            // 取结果集中的元素和当前元素进行比较、
            // 如果当前元素 左坐标比结果集的最后一个元素 右坐标小，
    		//则将结果集的最后一个元素进行合并，并加入结果集，成为末尾元素
              
if(intervals[i][0] <= result.getLast()[1]){
                //开始坐标就是 结果集 中的 结尾坐标的左节点
int start = result.getLast()[0];
                //结束坐标就是 当前比较的坐标的最大节点
int end  = Math.max(intervals[i][1],result.getLast()[1]);
                // 移除结果集中的 最后一个坐标 
result.removeLast();
                // 并将当前坐标加入结果集
result.addLast(new int[]{start,end});
            // 如果当前元素 左坐标比结果集的最后一个元素 右坐标大，
    		//则将当前元素直接加入结果集，成为末尾元素
}else{
 result.add(intervals[i]);
}

}
return result.toArray(new int[result.size()][]);
```

###### 求交集类题

```java
// 求交集
            LinkedList<int []>  result = new LinkedList<>();
            //双指针
            int first = 0;
            int second = 0;
           while(first < firstList.length  &&  second < secondList.length){
               //左边取最大值
               int left = Math.max(firstList[first][0],secondList[second][0]);
               //右边取最小值
               int right = Math.min(firstList[first][1],secondList[second][1]);
                //能够满足基本的区间成立条件
               if(left <= right)     result.add(new int[]{left,right});
               if(firstList[first][1]< secondList[second][1]){
                   first++;
               }else{
                   second++;
               }

           }
            return result.toArray(new int[0][]);
```

###### 求拼接类题

```java
if(clips[0][0] != 0 )   return -1;
int nexttime = 0;
int start =0;
int res =1;
for(int i = 0;i<clips.length;i++){
   //新的 左侧边界 比start 大的时候
if(clips[i][0] > start){
     start = nexttime ;  //将 start 赋值为  上一轮的nexttime, 此时出现了新的start
     res++;          //出现新的 start 再++
}
if(clips[i][0] <= start){  ////新的 左侧边界 比start 小的时候 不一定替换
      nexttime = Math.max(nexttime, clips[i][1]);   //出现新的nexttime
      if(nexttime >= time) break;
}
}
if(nexttime < time)   return -1;
return res;
```

## ==DFS==

#### 一般模版

```java
void dfs(int[][] grid, int i, int j, boolean[][] visited) {
    int m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 超出索引边界
        return;
    }
    if (visited[i][j]) {
        // 已遍历过 (i, j)
        return;
    }
    // 进入节点 (i, j)
    visited[i][j] = true;
    dfs(grid, i - 1, j, visited); // 上
    dfs(grid, i + 1, j, visited); // 下
    dfs(grid, i, j - 1, visited); // 左
    dfs(grid, i, j + 1, visited); // 右
}
```

```java
// 方向数组，
//分别代表上、下、左、右
int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};

void dfs(int[][] grid, int i, int j, boolean[][] visited) {
    int m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 超出索引边界
        return;
    }
    if (visited[i][j]) {
        // 已遍历过 (i, j)
        return;
    }

    // 进入节点 (i, j)
    visited[i][j] = true;
    // 递归遍历上下左右的节点
    for (int[] d : dirs) {
        int next_i = i + d[0];
        int next_j = j + d[1];
        dfs(grid, next_i, next_j, visited);
    }
    // 离开节点 (i, j)
}
```

#### 二维数组（网格）中的DFS

一般的位置为上下左右 的4 个位置<==比如经典的岛屿问题==>

也可能是上下左右  左上左下  右上右下  的8 个位置



##### **引入：**

先理解一下二叉树的 递归（DFS 遍历）

```java
void traverse(TreeNode root) {
    // 判断 base case      ---------要素1
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点--------要素2
    traverse(root.left);
    traverse(root.right);
}
```

##### 网格

###### 两个要素

- **basecase**

就是   网格中不需要继续遍历、`grid[r][c]` 会出现数组下标越界异常的格子 即：

<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304191221218.png" alt="image-20230419122140180" style="zoom:25%;" />

>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？
>
>可以称之为  「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。
>
>这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。

- **相邻节点   ————四叉结构**

<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202304191219258.png" style="zoom:25%;" />



```java
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    // 如果坐标 (r, c) 超出了网格范围，直接返回
    if (!inArea(grid, r, c)) {
        return;
    }
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length 
        	&& 0 <= c && c < grid[0].length;
}
```

##### 如何避免遇到的重复情况呢

- 就是再使用一个变量（visited）将所有经过的节点 都进行标记

- 或者    如果是节省空间的话还可以 在其基础上直接更改当前位置的值比如： 直接将`grid[i][j]=1`改为 `grid[i][j] = 2`;



岛屿类问题的解法：



| 题目                                                         |
| ------------------------------------------------------------ |
| [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/) |
| [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/) |
| [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/) |
| [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/) |
| [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/) |
| [463 岛屿的周长][https://leetcode.cn/problems/island-perimeter/] |
| [130 被围绕的区域][https://leetcode.cn/problems/surrounded-regions/] |

上面的5 题的`dfs`函数代码都是一样的

> dfs的主要操作  : 在岛屿问题中的主要操作 就是 将遍历过的点  用海水继续覆盖掉  防止走回头路

```java
//dfs

	void dfs(int [][]grid, int i,int j){
        int m=grid.length;
        int n = grid[0].length;
        //base case
        if(i<0 || j<0||i>=m||j>=n  || grid[i][j] != 陆地) return ;
        if(grid[i][j] != 陆地) return ;
		// dfs  的主要操作
        grid[i][j] = 非海水、非陆地de值;
        
        //相邻节点
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }

//特别的是：岛屿的最大面积
// 相邻节点 应该这么写
int dfs(int [][]grid, int i,int j){
   int m=grid.length;
        int n = grid[0].length;
        //base case
        if(i<0 || j<0||i>=m||j>=n  || grid[i][j] != 陆地) return 0;
        if(grid[i][j] != 陆地) return 0;
		// dfs  的主要操作
        grid[i][j] = 非海水、非陆地de值;
        
        return dfs(grid,i,j-1)+
        dfs(grid,i,j+1)+
        dfs(grid,i-1,j)+
        dfs(grid,i+1,j)+1 ;
        
}

//周长
int dfs(int [][]grid, int i,int j){
   int m=grid.length;
        int n = grid[0].length;
        //base case
        if(i<0 || j<0||i>=m||j>=n  || grid[i][j] != 陆地) return 1;
        if(grid[i][j] != 陆地)   return 1 ;
		// dfs  的主要操作
        grid[i][j] = "非海水、非陆地de值";
        
        return dfs(grid,i,j-1)+
        dfs(grid,i,j+1)+
        dfs(grid,i-1,j)+
        dfs(grid,i+1,j)+1 ;
        
}


```

`主函数代码`

>值得注意的是  `每一次 dfs 之后就会将 所有的 陆地  置为  0  所以每一次的开始 dfs 的条件就是   if(grid[i][j] == 陆地)`

```java
public int numIslands(char[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int count =0;
       
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ......
            }
        }
        return  ...;
}
//200
......
if(grid[i][j] == 陆地){
     res++;            
     dfs(grid,i,j);  // dfs找到所有的 链接岛屿群 并淹没  
}


return  res;

//1254
for (int i = 0; i < n; i++) {
     dfs(grid,0,i);
     dfs(grid,m-1,i);
}

for (int i = 0; i < m; i++) {
    dfs(grid,i,0);
    dfs(grid,i,n-1);
}

if(grid[i][j] == 陆地){
    res++;  
    dfs(grid,i,j);  // dfs找到所有的 链接岛屿群 并淹没  
}


return  res;


//1020
for (int i = 0; i < n; i++) {
     dfs(grid,0,i);
     dfs(grid,m-1,i);
}

for (int i = 0; i < m; i++) {
    dfs(grid,i,0);
    dfs(grid,i,n-1);
}

if(grid[i][j] == 陆地){
    res++;  
}


return  res;


//1905
//先将在  grid2是陆地  和在   grid1 是海水   地方 在grid2 中全部设置为 海水
        for (int i = 0; i < grid1.length;i++){
            for (int j = 0; j <grid1[0].length ; j++) {
                if(grid2[i][j] ==1 && grid1[i][j] == 0){
                    dfs(grid2,i,j);
                }
            }
        }
// 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid2[i][j] == 1){
                    dfs(grid2,i,j);
                    res++;
                }
            }
        }
        return  res;

//695
  		for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] ==1){
                    res = Math.max(res,dfs(grid,i,j));
                }
            }
        }
        return res;  
   

//463
		for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] ==1){
                    return  dfs(grid,i,j);
                }
            }
        }
        return 0;


//130
int m = board.length;  //行
        int n = board[0].length;  //列
        for (int i = 0; i < n; i++) {
            if(board[0][i] == 'O')   dfs(board,0,i);
            if(board[m-1][i] == 'O') dfs(board,m-1,i);
        }
        for (int i = 0; i < m; i++) {
            if(board[i][0] == 'O')   dfs(board,i,0);
            if(board[i][n-1] == 'O') dfs(board,i,n-1);
        }

        for(int i = 0; i <m; i++){
            for (int j = 0; j < n; j++) {
                if(board[i][j] == '#')    board[i][j] = 'O';
                else if(board[i][j] == 'O')    board[i][j] = 'X';
            }
        }

```

##### ==一道困难的DFS==

```java
//827(两次bfs   一次遍历海水  一次遍历陆地)
public int largestIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int areaMark = 2;
        int res = 0;
        HashMap<Integer, Integer> map = new HashMap<>();

        // 第一次  DFS 进行 各个陆地的面积 计算
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] == 1){
                    int area = dfs(grid, i, j,areaMark);
                    map.put(areaMark,area);
                    areaMark++;
                    res = Math.max(res, area);
                }
            }
        }

        if(res == 0) return 1;

        // 第二次  DFS  进行海水 变陆地
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] == 0){
                    HashSet<Integer> hashset = dfs2(grid, i, j); //把上下左右四邻放入set里，set的目的是去重
                    if (hashset.size() < 1)  continue;
                    int addIsland = 1;
                    for (Integer set : hashset) {
                        addIsland += map.get(set);
                        res = Math.max(res, addIsland);
                    }

                }
            }
        }
        return res;
    }

    private int dfs(int[][] grid, int i, int j, int areaMark) {

        int m = grid.length;
        int n = grid[0].length;

        if(i>=m ||j >= n || j < 0 || i < 0 || grid[i][j] != 1)  return 0;
        // 标记为已经遍历过了
        grid[i][j] = areaMark;
        // 就是求飞地的数量
        return 1+dfs(grid, i-1, j,areaMark) + dfs(grid, i+1, j, areaMark)+
                dfs(grid, i, j-1,areaMark) + dfs(grid, i, j+1, areaMark) ;
    }

    private HashSet<Integer> dfs2(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        HashSet<Integer> set = new HashSet<>();
        if(i+1<m && j < n && j >= 0 && i+1 >= 0 && grid[i+1][j] != 0)
        set.add(grid[i+1][j]);
       if(i-1<m && j < n && j >= 0 && i-1 >= 0 && grid[i-1][j] != 0)
        set.add(grid[i-1][j]);
        if(i<m && j+1< n && j+1 >= 0 && i >= 0 && grid[i][j+1] != 0)
        set.add(grid[i][j+1]);
       if(i<m && j-1 < n && j-1 >= 0 && i >= 0 && grid[i][j-1] != 0)
        set.add(grid[i][j-1]);
        return set;
    }
```

#### 8个方向

##### 扫雷游戏

```java
//DFS
    int dirs[][] = {{1,0},{1,1},{0,1},{0,-1},{-1,0},{-1,1},{1,-1},{-1,-1}};
    //M  X  1-8  都是和地雷相关
    public char[][] updateBoard(char[][] board, int[] click) {
        int i = click[0];
        int j = click[1];
        if(board[i][j] == 'M')
            board[i][j] ='X';
        else
            dfs(board,i,j);

        return board;
    }

    private void dfs(char[][] board, int i, int j) {
        int count =0;
        
        
        for (int k = 0; k < dirs.length; k++) {
            int newx = i + dirs[k][0];
            int newy = j + dirs[k][1];
            if(newy < 0 || newx < 0 || newx >= board.length || newy >= board[0].length) continue;
            if(board[newx][newy] == 'M') count++;
        }
        
        
        if(count > 0) board[i][j] = (char)(count+'0');
        else {
            board[i][j] = 'B';
            for (int k = 0; k < dirs.length; k++) {
                int newx = i + dirs[k][0];
                int newy = j + dirs[k][1];
                if(newy < 0 || newx < 0 || newx >= board.length || newy >= board[0].length || board[newx][newy] !='E') continue;
                dfs(board, newx, newy);
            }
        }
    }



```

```java
//BFS

    int dirs[][] = {{1,0},{1,1},{0,1},{0,-1},{-1,0},{-1,1},{1,-1},{-1,-1}};
    //M  X  1-8  都是和地雷相关
    public char[][] updateBoard(char[][] board, int[] click) {
        int m = board.length;
        int n = board[0].length;
        int i = click[0];
        int j = click[1];

        //'X' 则表示一个 已挖出的 地雷  如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X' 
        if(board[i][j] == 'M')
            board[i][j] ='X';
        else
        //bfs处理 E B  数字 三者逻辑
            bfs(board,i,j);
//如果在此次点击中，若无更多方块可被揭露，则返回盘面。
        return board;
    }

  private void bfs(char[][] board, int i, int j) {

        Queue<Integer> queue = new LinkedList<>();
        boolean visited[][] = new boolean[board.length][board[0].length];

        queue.offer(i);
        queue.offer(j);
        visited[i][j] =true;
        while(!queue.isEmpty()) {
            int count =0;
            int x = queue.poll();
            int y = queue.poll();
            
            
            for (int k = 0; k < dirs.length; k++) {
                int newx = x + dirs[k][0];
                int newy = y + dirs[k][1];
                if(newy < 0 || newx < 0 || newx >= board.length || newy >= board[0].length) continue;
                if(board[newx][newy] == 'M') count++;
            }
            
            
            
            //如果一个 至少与一个地雷相邻 的空方块（'E'）被挖出，修改它为数字（'1' 到 '8' ），表示相邻地雷的数量。
            if(count > 0) board[x][y] = (char)(count+'0');
            else {
               // 如果一个 没有相邻地雷 的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。
                board[x][y] = 'B';
                for (int k = 0; k < dirs.length; k++) {
                    int newx = x + dirs[k][0];
                    int newy = y + dirs[k][1];
                    if(newy < 0 || newx < 0 || newx >= board.length || newy >= board[0].length || board[newx][newy] !='E' || visited[newx][newy]) continue;
                        queue.offer(newx);
                        queue.offer(newy);
                        visited[newx][newy] = true;
                }
            }

        }

    }
```

#### 树/图的DFS





##### 困难一

>```java
>// 332
>// 困难 的 回溯  安排行程    所有的机票 必须都用一次 且 只能用一次
>List<String> res = new ArrayList<>();     // 结果集
>LinkedList<String> path = new LinkedList<>();    // 路径
>boolean  visited[];
>public List<String> findItinerary(List<List<String>> tickets) {
>
>    visited = new boolean[tickets.size()+1];
>
>
>   // 对  目的地(下标为 1)进行  排序
>   Collections.sort(tickets,(o1,o2) -> o1.get(1).compareTo(o2.get(1)));
>
>   //所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始
>   path.add("JFK");
>//细节一: 强转为 ArrayList
>   trackback((ArrayList) tickets);
>   return res;
>}
>//细节二: 
>private boolean trackback(ArrayList<List<String>> tickets) {
>   if(path.size() == tickets.size()+1){ //找到 符合的所有路径  
>       res =new ArrayList<>(path);
>       return true;                     //结束回溯
>   }
>   for (int i = 0; i < tickets.size(); i++) {
>       // 未访问过    &&    本票的 出发地  是队列中 最后一个元素（上一个票的 目的地）
>       if(!visited[i] && tickets.get(i).get(0).equals(path.getLast())){
>           // 做选择
>          path.add(tickets.get(i).get(1));
>          visited[i] = true;
>          if(trackback(tickets)) return true;     //结束回溯
>           //撤销选择
>          visited[i] = false;
>          path.removeLast();
>      }
>   }
>   return false;
>}
>
>```

>进阶写法：
>
>Map   computeIfAbsent      PriorityQueue

>```java
>//332
>// 困难 的 DFS  安排行程    所有的机票 必须都用一次 且 只能用一次
>class Solution {
>//要点一 : 贪心 : 按照字典顺序访问，我们把每个顶点的临接点按照字典顺序  排序
>           // 也 可以不对临接点排序，而是使用小顶堆（Java可以用优先队列）。这样我们删除边的操作和访问最小字典顺序顶点可以用 出队操作代替，时间复杂度应该会比排序再删除要低一些。
>
>//要点二 : DFS(回溯) : 遍历图时，需要将访问到的节点  逆序  插入到结果集
>//要点三 : 避免存在环路导致节点重复访问，我们  每访问过   一条边  就把它标记为访问过，或者直接将  访问过的边  删除  然后 每次都取临接点的第一个即可满足字典顺序访问
>
>//computeIfAbsent  该方法适用于需要在 Map 中进行查找或计算某些值的场景，比如对于需要动态生成某些值的场景
>
>LinkedList<String> res = new LinkedList<>();
>public List<String> findItinerary(List<List<String>> tickets) {
>   if(tickets.size() == 0  || tickets == null ) return res;
>   // Map<String, List<String>> 存储 图，Key 为顶点，List<String> 为临接点。
>   HashMap<String, PriorityQueue<String>> graph = new HashMap<>();
>   for (List<String>  ticket : tickets) {
>       //排序
>
>       //如果 graph 中不存在以 ticket.get(0) 为键的映射，则创建一个新的 PriorityQueue 实例，并将其作为该键值对应的值存入 graph 中；否则，直接返回对应的 PriorityQueue 对象。
>       PriorityQueue<String> queue = graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>());
>       queue.add(ticket.get(1));
>   }
>
>   //dfs
>   dfs(graph,"JFK");
>   return res;
>}
>
>private void dfs(HashMap<String, PriorityQueue<String>> graph, String start) {
>   PriorityQueue<String> queue = graph.get(start);
>   while (queue!=null && queue.size() > 0) {
>       String poll = queue.poll();
>       dfs(graph, poll);
>   }
>   res.add(0,start);  // 逆序插入
>}
>}
>```

##### 困难二

>公共公交

>```java
>// 无(双)向图
>public int numBusesToDestination(int[][] routes, int source, int target) {
>
>   if(source == target) return 0;
>   int res = bfs(routes, source, target);
>   return  res;
>}
>
>
>
>private int bfs(int[][] routes, int source, int target) {
>   // 邻接表记录   站 与   路线的  关系
>   HashMap<Integer,List<Integer>> graph = new HashMap<>();
>
>   int count =0;
>   // 记录：经过的路线
>   Deque<Integer> queue = new LinkedList<>();
>
>   Set<Integer> visited= new HashSet<>();
>
>
>   int numOfRoutes = routes.length;
>   //将每个站点出现在的路线号添加到哈希表中。
>   // 在循环遍历每个路线时，对于路线中的每个站点 station，
>   //          首先判断是否已经存在以 station 为键的值，
>   //          如果不存在，则在哈希表中添加一个新的空列表；然后将该路线编号 i 添加到哈希表中以 station 为键的值所对应的列表中。
>   //          最后得到的是一个包含每个站点出现在的路线编号的哈希表。
>   for (int i = 0; i < numOfRoutes; i++) {
>       for (int station : routes[i]) {
>
>           if(!graph.containsKey(station)){
>               graph.put(station,new ArrayList<>());
>           }
>           graph.get(station).add(i);
>       }
>   }
>
>   queue.addAll(graph.get(source));
>   visited.addAll(graph.get(source));
>
>   while(!queue.isEmpty()){
>       int size = queue.size();
>       count++;
>       for (int i = 0; i < size; i++) {
>           int poll =  queue.poll();
>           int[] route = routes[poll];
>           for (int station: route){
>
>               if(station == target)  return count;
>
>               for (int bus : graph.getOrDefault(station, new ArrayList<>())) {
>                   if(!visited.contains(bus)) {
>                       queue.offer(bus);
>                       visited.add(bus);
>                   }
>
>               }
>           }
>       }
>   }
>   return  -1;
>}
>
>```



##### 困难三

>[单词接龙](https://leetcode.cn/problems/word-ladder/)
>
>```java
>//127
>public int ladderLength(String beginWord, String endWord, List<String> wordList) {
>   // 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里
>   Set<String> wordSet = new HashSet<>(wordList);
>   if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
>       return 0;
>   }
>   wordSet.remove(beginWord);
>
>   // 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表
>   Queue<String> queue = new LinkedList<>();
>   queue.offer(beginWord);
>   Set<String> visited = new HashSet<>();
>   visited.add(beginWord);
>
>   // 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1
>   int step = 1;
>   while (!queue.isEmpty()) {
>       int currentSize = queue.size();
>       for (int i = 0; i < currentSize; i++) {
>           // 依次遍历当前队列中的单词
>           String currentWord = queue.poll();
>           // 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1
>           if (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) {
>               return step + 1;
>           }
>       }
>       step++;
>   }
>   return 0;
>}
>
>/**
>    * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配
>    *
>    * @param currentWord
>    * @param endWord
>    * @param queue
>    * @param visited
>    * @param wordSet
>    * @return
>    */
>   private boolean changeWordEveryOneLetter(String currentWord, String endWord,
>                                            Queue<String> queue, Set<String> visited, Set<String> wordSet) {
>       char[] charArray = currentWord.toCharArray();
>       for (int i = 0; i < endWord.length(); i++) {
>           // 先保存，然后恢复
>           char originChar = charArray[i];
>           for (char k = 'a'; k <= 'z'; k++) {
>               if (k == originChar) {
>                   continue;
>               }
>               charArray[i] = k;
>               String nextWord = String.valueOf(charArray);
>               if (wordSet.contains(nextWord)) {
>                   if (nextWord.equals(endWord)) {
>                       return true;
>                   }
>                   if (!visited.contains(nextWord)) {
>                       queue.add(nextWord);
>                       // 注意：添加到队列以后，必须马上标记为已经访问
>                       visited.add(nextWord);
>                   }
>               }
>           }
>           // 恢复
>           charArray[i] = originChar;
>       }
>       return false;
>   }
>```
>
>











## ==BFS==



>- **BFS 找到的路径一定是最短的**
>
>- 问题的本质就是让你在一幅「图」中找到从起点 `start` 到终点 `target` 的最近距离.  找==最短路径==
>
>- 也就是说  只有在   找最短路径的时候 用 BFS    其他时候 大部分还是DFS

#### BFS在层次遍历中模版：

##### 返回值是二维数组：

>大部分题目就是在这个的基础上进行修改<核心代码 前置>

```java
List<List<Integer>> result = new ArrayList<List<Integer>>();       结果集
Queue<TreeNode> queue = new LinkedList<>();							队列
    // 要是定义在这里就只能打印得到一个整体的一维数组，因为每次for 循环中不会重置该一维数组
    //   ArrayList<Integer> tmpList  = new ArrayList<>();
    //加入根节点
queue.offer(root);													入队
        //判空，返回的要是二维数组不能是null
if(root == null)  return result;									
while(!queue.isEmpty()){
int queueSize = queue.size();										队列的大小
// 必须要这里定义一维数组,只有在这里定义的才能每层都放在不同的一维数组里面，最终构成二维数组  并且只有 这里定义 tmpList 才能之后在 while中直接加到 result中  即：result.add(tmpList);              
//每层遍历的时候 tmpList 都会重置
 
ArrayList<Integer> tmpList  = new ArrayList<>();                   临时接受
for(int i = 0; i < queueSize;i++){
		TreeNode outQueue = queue.poll();              				出队
       if(outQueue.left!=null) queue.offer(outQueue.left);			左右侧进行递归
       if(outQueue.right!=null) queue.offer(outQueue.right);
       tmpList.add(outQueue.val);									临时接受
}	
result.add(tmpList);												进结果集
}
 return result;
```

##### 返回值是一维数组：

>大部分题目就是在这个的基础上进行修改<核心代码 前置>

```java
ArrayList<Integer> result = new ArrayList<>();
Queue<TreeNode> queue = new LinkedList<>();

if(root == null)  return result;
queue.offer(root);
while(!queue.isEmpty()){
             
            
int  queueSize = queue.size();
for(int i=0;i<queueSize;i++){
TreeNode outqueue = queue.poll();
      result.add(outqueue.val);
      if(outqueue.left!= null)   queue.add(outqueue.left);
      if(outqueue.right!= null)  queue.add(outqueue.right);
}
}
return result;
```

>不难看出 就是在 **定义结果集的时候**  有区别，也就是结果集 **维度** 和 **位置** 的 区别

#### BFS的框架模版

```java
// 计算从起点 start 到终点 target 的最近距离               
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构                       
	q.offer(start); // 将起点加入队列
    
    --------------  区别之处
    Set<Node> visited; // 避免走回头路     二叉树不用
    visited.add(start);
    int step = 0; // 记录扩散的步数

    
    
    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            
     ----------------  区别之处
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {    //cur.adj() 泛指 cur 相邻的节点
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
            
            
        }
     ----------------  区别之处
        /* 划重点：更新步数在这里 */
        step++;
    }
}



//visited 的主要作用是防止走回头路，大部分时候都是必须的，
//但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。
```

>==注意==:
>
>这个 `while` 循环和 `for` 循环的配合
>
>**`while` 循环控制一层一层往下走，`for` 循环利用 `sz` 变量控制从左到右遍历每一层二叉树节点**：
>
><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303231104890.png" style="zoom:25%;" />
>
>

> 感悟：
>
> ==对于含有 `for` 或者 `其他 (while 等)循环`的代码中，对于想要得到的结果，往往是在循环之外进行数据处理的，例如 `返回结果，取最大值等等`==

#### 岛屿问题的BFS

```java
bfs 函数的基本框架
    
    
    int  [][]dirs = {{1,0},{-1,0},{0,1},{0,-1}};
    
    void/int bfs(int/... [][]grid, int  i , int  j ){
    int  m = grid.length;
    int  n = grid[0].length;
        
        
            
    //第一种写法   必须是 n
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(i * n + j );   
    grid[i][j] = 海洋/'0'/...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历   第一次加入
    int out = queue.poll();
    int x = out / n;
    int y = out % n;
    for(int  k=0 ;k<dirs.length;k++){
        int newx = x+dirs[k][0];
        int newy = y+dirs[k][1];
        
        if(newx >= 0 && newy >=0 &&  newx < m && newy < n && grid[newx][newy]== "陆地"){
           queue.offer(newx * n  + newy); 
            grid[i][j] = 海洋/'0'/...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入
        }
        
    }
        
        //第二种写法
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(i);
    queue.offer(j);
    grid[i][j] = 海洋/'0'/...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历   第一次加入
    .........(//695   step++;)
    .........(//1020  step++;)
    int x = queue.poll();
    int y = queue.poll();
    for(int  k=0 ;k<dirs.length;k++){
        int newx = x+dirs[k][0];
        int newy = y+dirs[k][1];
        
        if(newx >= 0 && newy >=0 &&  newx < m && newy < n && grid[newx][newy]== "陆地"){
            queue.offer(newx); 
            queue.offer(newy); 
            grid[i][j] = 海洋/'0'/...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入
        }
        
    }
     
        //第三种写法
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{i,j});
    grid[i][j] = 非海洋非陆地的值/'2'/2...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历 第一次加入
    int out[] = queue.poll();
    int x = out[0];
    int y = out[1];
    for(int  k=0 ;k<dirs.length;k++){
        int newx = x+dirs[k][0];
        int newy = y+dirs[k][1];
        
        if(newx >= 0 && newy >=0 &&  newx < m && newy < n && grid[newx][newy]== "陆地"){
            queue.offer(new int{newx,newy}); 
            grid[newx][newy] = 非海洋非陆地的值/'2'/2...;  // 入队的时候而不是出队的时候加入  可以保证不会重复遍历  第二次加入
            .........(//695   step++;)
            .........(//1020  step++;)
        }
         /**463 周长 附加判断 
            //bfs 按圈进行扩展  所以每一轮扩展之后 都将会对每一个当前节点的一圈节点进行遍历  
            //所以正好可以利用这个特性对其进行计算周长，看四边是不是 0 是的话就 周长+1 
                if( newx < 0  ||  newy <0 ||  newx >=m ||  newy >=n ||  grid[newx][newy] !=1) {                  
                   if( newx <0  ||  newy <0 ||  newx >=m ||  newy >=n ||  grid[newx][newy]== 0 ) {  
                       count++;
                }
                continue;
            }
        }
    }
     return count;
         */
        
    }
        
    
}
```

```java
//200
 		int count = 0;
        int m = grid.length;
        int n = grid[0].length;
       
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
               if(grid[i][j]=='1'){
                  bfs(grid,i,j);
                  count++;
              }
            }
        }
        return count;
    }


//695
------<bfs 有变动>
		int m = grid.length;
        int n = grid[0].length;
    
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <n; j++) {
                if(grid[i][j] == 1){
                    //每一次的 bfs 都要初始化  才能进行比较 取得 最值
                    step = 0;
                    bfs(grid,i,j);
                    res = Math.max(res,step);
                }
            }
        }
        return res ;




//1905
  
        int m = grid1.length;
        int n = grid1[0].length;
        int res = 0;
        //先将在  grid2是陆地  和在   grid1 是海水   地方 在grid2 中全部设置为 海水
        for (int i = 0; i < grid1.length;i++){
            for (int j = 0; j <grid1[0].length ; j++) {
                if(grid2[i][j] ==1 && grid1[i][j] == 0){
                    bfs(grid2,i,j);
                }
            }
        }

        // 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid2[i][j] == 1){
                    bfs(grid2,i,j);
                    res++;
                }
            }
        }
        return  res;
    

//1020
------<bfs 有变动>
    int step ;

 		int m = grid.length;
        int n = grid[0].length;
        int res = 0;
        for (int i = 0; i < m; i++) {
            if (grid[i][0] == 1) bfs(grid, i, 0);
            if (grid[i][n-1] == 1) bfs(grid, i, n - 1);
        }
        // 从上边和下边向中间遍历
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 1) bfs(grid, 0, j);
            if (grid[m - 1][j] == 1) bfs(grid, m - 1, j);
        }
        step = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if( grid[i][j] == 1){
                    bfs(grid,i,j);
                }
            }
        }
        return step;


//1254<与 1020 几乎一模一样>
        int m = grid.length;
        int n = grid[0].length;
        int res = 0;
        for (int i = 0; i < n; i++) {
            if(grid[0][i] == 0)   bfs(grid,0,i);
            if(grid[m-1][i] == 0) bfs(grid,m-1,i);
        }
        for (int i = 0; i < m; i++) {
           if(grid[i][0] == 0) bfs(grid,i,0);
            if(grid[i][n-1] == 0)  bfs(grid,i,n-1);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] == 0){
                    bfs(grid,i,j);
                    res++;
                }
            }
        }
        return res;
//463 
 		int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(grid[i][j] ==1){
                    res=bfs(grid,i,j);
                }
            }
        }
        return res;
    }
//130 
	for (int i = 0; i < n; i++) {
            if(board[0][i] == 'O')   bfs(board,0,i);
            if(board[m-1][i] == 'O') bfs(board,m-1,i);
        }
        for (int i = 0; i < m; i++) {
            if(board[i][0] == 'O')   bfs(board,i,0);
            if(board[i][n-1] == 'O') bfs(board,i,n-1);
        }

        for(int i = 0; i <m; i++){
            for (int j = 0; j < n; j++) {
                if(board[i][j] == '#')    board[i][j] = 'O';
                else if(board[i][j] == 'O')    board[i][j] = 'X';
            }
        }

```

#### 一道BFS\DFS 的综合应用

```java
//934  最短的桥
class Solution {
    LinkedList<int[]> queue = new LinkedList<>();
    int dirs[][] = {{1,0},{-1,0},{0,1},{0,-1}};
    int res = 0;
    boolean onlyOne = false; 
    public int shortestBridge(int[][] grid) {
        //四面相连 == 上下左右
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            if(onlyOne) break;
            for (int j = 0; j < n; j++) {
                if(grid[i][j] == 1 && !onlyOne){
                    onlyOne = true;
                    dfs(grid,i,j);
                    break;
                }
            }
        }
      
        return bfs(grid);
    }
  // 计算扩展的层数，就是桥的个数
    private int bfs(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        while (!queue.isEmpty()) {
            res++;
            int size = queue.size();
            for (int l = 0; l < size; l++) {
                int[] poll = queue.poll();
                int x = poll[0];
                int y = poll[1];
                for (int k = 0; k < dirs.length; k++) {
                    int newx = x + dirs[k][0];
                    int newy = y + dirs[k][1];
                    if(newx >= 0 && newy >= 0 && newx < m && newy < n && grid[newx][newy] == 0) {
                            queue.offer(new int[]{newx, newy});
                            grid[newx][newy] = 2;
                    }else if(newx >= 0 && newy >= 0 && newx < m && newy < n && grid[newx][newy] == 1){
                        return res;
                    }
                }
            }
        }
        return res;
    }


    //找到岛屿，岛屿的个数
    private void dfs(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 2 ) return ;

        if(grid[i][j] == 1){
            grid[i][j] = 2;

        }
        if(grid[i][j] == 0){  //只 向外 扩展一层 即可  所以是 if
            grid[i][j] = 2;
            queue.offer(new int[]{i, j});
            return ;
        }
        dfs(grid, i, j+1);
        dfs(grid, i+1, j);
        dfs(grid, i-1, j);
        dfs(grid, i, j-1);
    }

}
```



## 滑动窗口题：

>==注==
>
>​	将 索引**左闭右开**区间 `[left, right)` 称为一个「窗口」

##### 核心框架

```java
// 核心逻辑
int left = 0, right = 0;
while (right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;   
    ........
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

##### 整体框架

```java
完整框架
    
/* 滑动窗口算法框架 */
void slidingWindow(String s) {
    Map<Character, Integer> window = new HashMap<>();
//（ 变量 ）
    int left = 0, right = 0;
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s.charAt(right);
		// 增大窗口
        right++;
// 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时
        System.out.printf("window: [%d, %d)\n", left, right);
        /********************/
        
// 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s.charAt(left);
            // 缩小窗口
            left++;
// 进行窗口内数据的一系列更新
            ...
        }
    }
}
其中两处 ... 表示的更新窗口数据的地方，到时候直接往里面填就行了。
而且，这两个 ... 处的操作分别是扩大和缩小窗口的更新操作，等会你会发现它们操作是完全对称的。
    
```



>==思考==
>
>- 什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？
>- 什么时候应该移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？
>- 我们要的**结果**应该在扩大窗口时还是缩小窗口时进行更新？



##### ==java相关的知识==

>```java
>// 将 string  转为字符串 
>for(char c:t.toCharArray()){
>//将 c  加到对应的map结合中，  要是有的话就+1，没有就为 0+1
>request.put(c,request.getOrDefault(c,0)+1);
>}
>
>//map用于 判断是否含有 该键
>if(request.containsKey(remover))
>if(window.get(remover).equals(request.get(remover))) 
>//两个map集合中的键值都一样才为true
>
>```





##### 一个字符串 / 数组

>```java
>//3  给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。        
>
>----变量
>HashMap<Character, Integer> window = new HashMap<>();
>int left = 0;
>int right = 0;
>int count = 0;
>int res= 0;
>
>----进行窗口内数据的一系列更新
>// 窗口的大小进行更新； 窗口中的键值更新
>window.put(add,window.getOrDefault(add,0)+1);
>count++;
>
>----判断左侧窗口是否要收缩
>//窗口缩小的条件： 窗口中的键对应的值 >1 
>while(window.get(add)>1)
>
>----进行窗口内数据的一系列更新
>// 窗口的大小进行更新； 窗口中的键值更新
>  count --;
>  window.put(remove,window.get(remove)-1);
>----返回值
>//结果集收集：记录每一次的最大值
>       res = Math.max(res,count);
>
>
>
>
>//209   长度最小的子数组   满足其和 ≥ target 的长度最小的 连续子数组  并返回其长度。如果不存在符合条件的子数组，返回 0 。 
>
>----变量
>		int left = 0;
>   int right= 0;
>   int sum = 0;
>   int res = Integer.MAX_VALUE;
>   int count = 0;   
>----进行窗口内数据的一系列更新
>	 if(sum < target){
>           sum =sum+add;
>           //window.put(add,window.getOrDefault(add,0 )+1);
>           count++;
>       }
>----判断左侧窗口是否要收缩
>while(sum >= target)
>----进行窗口内数据的一系列更新
>if(sum >= target){
>  res = Math.min(res,count);
>}
>  sum =sum-remove;
>  count--;
>
>----返回值
>return res== Integer.MAX_VALUE? 0:res;
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>// 模版框架有变动
>//1004   给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。
>----变量
>		int right= 0;
>   int left= 0;
>   int count = 0;
>   int res = k;
>
>----进行窗口内数据的一系列更新
>// 扩大窗口的时候 k 是可以等于 0  的 ，
>// 否则要是在扩大窗口的时候  只判断 k>0 会导致 count 的值会变小，
>// 原因是一旦 K == 0;就会使窗口在遇到 k 个0 之后不管最后一个 0 后面的值是否为1 直接缩小窗口，就会导致 计数不完整。
>// 所以 k=0 放在增加窗口的时候，就是为了判断最后一个0 的后面的值是0还是1 ，这个时候即使扩大窗口会多++一次； 但是在缩小窗口的时候还是会--，就会进行抵消；
>       if(nums[right] == 0 && k>=0){
>           k--;
>       }
>       right++;
>       count++;
>
>----判断左侧窗口是否要收缩
>
>while(k<0)
>
>----进行窗口内数据的一系列更新
>	if(nums[left]==0){
>               k++;
>           }
>           left++;
>           count--;
>       }
>
>----返回值
>//缩小完窗口进行收集结果
>res = Math.max(res,count);
>
>
>
>
>
>
>
>//1004   完整代码
>
>//思路：遇到 K个 0 之后就缩小窗口，比较每次的收集到的最大 count
>public int longestOnes(int[] nums, int k) {
>   int right= 0;
>   int left= 0;
>   int count = 0;
>   int res = k;
>   while(right<nums.length){
>// 扩大窗口的时候 k 是可以等于 0  的 ，
>//否则要是在扩大窗口的时候  只判断 k>0 会导致 count 的值会变小，
>//原因是一旦 K ==0;就会使窗口在遇到 k 个0 之后不管最后一个 0 后面的值是否为1 直接缩小窗口，就会导致 计数不完整。
>//所以 k=0 放在增加窗口的时候，就是为了判断最后一个0 的后面的值是0还是1 ，这个时候即使扩大窗口会多++一次； 但是在缩小窗口的时候还是会--，就会进行抵消；
>       if(nums[right] == 0 && k>=0){
>           k--;
>       }
>       right++;
>       count++;
>       while(k<0){
>           if(nums[left]==0){
>               k++;
>           }
>           left++;
>           count--;
>       }
>       //缩小完窗口进行收集结果
>       res = Math.max(res,count);
>   }
>   return res;
>}
>
>
>```



##### 两个子符串

>**76 438  567 共性 就是   子串可以无序 但是长度固定 个数一致**
>
>==1208则是要逐位比较==
>
>```java
>
>
>//76   给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 ""
>----变量
>	int right= 0;
>   int left = 0;
>   int start = 0;
>   int len = Integer.MAX_VALUE;
>   int count = 0;
>    HashMap<Character,Integer> request = new HashMap<>();
>    HashMap<Character,Integer>  window = new HashMap<>();
>    for(char c:t.toCharArray()){
>        request.put(c,request.getOrDefault(c,0)+1);
>    }
>
>----进行窗口内数据的一系列更新
>
>		if(request.containsKey(add)){
>           window.put(add,window.getOrDefault(add,0)+1);
>           if(window.get(add).equals(request.get(add)))
>           count++;
>       }
>
>----判断左侧窗口是否要收缩
>
>while(count == request.size())
>
>
>----进行窗口内数据的一系列更新
>
>			if(right- left<len){
>               start = left;
>               len  = right - left;
>           }
>
>
>
>				if(request.containsKey(remove)){
>                 if(window.get(remove).equals(request.get(remove)))
>                   valid--;
>                   // get(remove)-1
>                   window.put(remove,window.get(remove)-1);
>           }
>
>----返回值
>
>				return len ==  Integer.MAX_VALUE? "": s.substring(start,start+len);
>
>
>
>
>//438   给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。 
>----变量
>
>	int right = 0;
>   int left = 0;
>   int count = 0;
>   HashMap<Character, Integer> request = new HashMap<>();
>   HashMap<Character, Integer> window = new HashMap<>();
>		for(char c : p.toCharArray()){
>       request.put(c,request.getOrDefault(c,0)+1);
>   }
>
>   ArrayList<Integer> result = new ArrayList<>();
>
>
>
>----进行窗口内数据的一系列更新
>
>		if(request.containsKey(add)){
>           window.put(adder,window.getOrDefault(add,0)+1);
>           if(window.get(add).equals(request.get(add)))
>               count++;
>           //System.out.println(window);
>       }
>
>----判断左侧窗口是否要收缩
>
>while(right-left >= p.length())
>
>
>----进行窗口内数据的一系列更新
>
>    		if(count == request.size()) {  //request.size()
>               result.add(left);
>           }
>				...
>				if(request.containsKey(remove)){
>               if(window.get(remove).equals(request.get(remove)))
>                   count--;
>
>               // window.put(remover, window.get(remover)-1);
>               window.put(remove, window.get(remove)-1);
>              // System.out.println(window);
>           }
>
>----返回值
>				return result;
>
>
>
>//567   给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false   和438几乎没差
>----变量
>	int right = 0;
>   int left = 0;
>   int count = 0;
>   HashMap<Character, Integer> request = new HashMap<>();
>   HashMap<Character, Integer> window = new HashMap<>();
>   for(char c : s1.toCharArray()){
>       request.put(c,request.getOrDefault(c,0)+1);
>   }
>
>----进行窗口内数据的一系列更新
>		if(request.containsKey(add)){
>           window.put(add,window.getOrDefault(add,0)+1);
>           if(window.get(add).equals(request.get(add)))
>          		count++;
>       }
>
>----判断左侧窗口是否要收缩
>while(right-left >= s1.length())
>
>----进行窗口内数据的一系列更新
>
>if(count == request.size())  return true;
>
>
>	if(request.containsKey(remove)){
>   if(window.get(remove).equals(request.get(remove)))
>       count--;
>   window.put(remove,window.get(remover)-1);
>}
>
>----返回值
>return false;
>
>
>
>
>
>
>// 模版框架有变动
>// 1208        如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。
>// 题意： cost 不是个数  而是|s[i] - t[i]| 就是两个字符的 ASCII 码值的差的绝对值
>----变量
>	int right= 0;
>   int left= 0;
>   int count = 0;
>   int diff = 0;
>   int res = 0;
>
>
>----进行窗口内数据的一系列更新
>		diff += Math.abs(s.charAt(right) - t.charAt(right));
>       right++;
>       count++;
>
>
>----判断左侧窗口是否要收缩
>
>while(diff>maxCost)
>
>
>----进行窗口内数据的一系列更新
>
>    diff -= Math.abs(s.charAt(left) - t.charAt(left));
>    left++;
>    count--;
>
>----返回值  
>// 更新值
>res = Math.max(res, count);
>
>
>
>
>
>//1208 完整代码
>
>// 题意： cost 不是个数  而是|s[i] - t[i]| 就是两个字符的 ASCII 码值的差的绝对值
>public int equalSubstring(String s, String t, int maxCost) {
>   int right= 0;
>   int left= 0;
>   int count = 0;
>   int diff = 0;
>   int res = 0;
>   // 窗口 扩大
>   while(right<s.length()){
>       diff += Math.abs(s.charAt(right) - t.charAt(right));
>       right++;
>       count++;
>       // 缩小窗口
>       while(diff>maxCost){
>           diff -= Math.abs(s.charAt(left) - t.charAt(left));
>           left++;
>           count--;
>       }
>       // 更新值
>       res = Math.max(res, count);
>   }
>   return res;
>}
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>----变量
>
>----进行窗口内数据的一系列更新
>
>----判断左侧窗口是否要收缩
>
>----进行窗口内数据的一系列更新
>
>----返回值
>
>```
>
>

## 二分搜索



>**不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。

>**另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

>
>
>- while(  <= )    <=\=>    right的赋值是` nums.length - 1 `   <==>    两端都闭区间 `[left, right]`
>
> - `left = mid + 1`   或者    `right = mid - 1`
>
>- while(  < )    <=\=>    right 的赋值是 `nums.length`     <==>    左闭右开区间 `[left, right)`
>
> - `left = mid + 1`  或者     `right = mid`
>
> 右侧边界的一个**特殊点**  就是结尾 获取left的时候要 -1

```java
//模板
	while(left <= right) {			---left < right					---left < right
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 		--- right=mid ; 						----right = mid ;
        } else if(nums[mid] == target) {
... //三选一 		  
 // 返回中点索引值				//左边界                    								//右边界
/**return mid;*/		/*right = mid - 1;**/   ---right = mid ;          /**left = mid + 1;*/  ----left = mid + 1 ;
        }
    }
--注意：
	----其实对于左右边界而言
	----返回的条件也是一样的，就是在 while(){}中有所变化
....... //三选一
 // 返回中点索引值		//左边界
 //return -1;  		//if (left == nums.length) return -1;				//if (left - 1 < 0) return -1;
                    // 判断一下 nums[left] 是不是 target                  // 判断一下 nums[left] 是不是 target
                    //return nums[left] == target ? left : -1;         //return nums[left - 1] == target ? (left - 1) : -1;
} 

```

#### 左右边界问题

```java
public static int[] searchRange(int[] nums, int target) {

        int [] result = new int[2];
        if(nums.length == 0) {
            result[0] = -1;
            result[1] = -1;
            return result;
        }
        int leftbound = GetLeftBound(nums,target);
        int rightbound = GetRightBound(nums,target);
        result[0] = leftbound;
        result[1] = rightbound;
        
        return  result;
    }


    static int GetLeftBound(int[] nums, int target){
        int right = nums.length;
        int left = 0;
        int mid = 0;
        while(left < right){   //[)
            mid = left + (right - left)/2;
            if(nums[mid] < target){
                left = mid  + 1;
            }else if(nums[mid] > target){
                right= mid ;
            }else if(nums[mid] == target){
                right = mid ;  // 缩小右边界 从而找到最左边界

            }
        }
       // System.out.println("nums["+left+"]=" + " "+nums[left]);
        if(left == nums.length ) return -1;
        return nums[left]  == target ? left :-1;
    }


    static int GetRightBound(int[] nums, int target){
        int right = nums.length;
        int left = 0;
        int mid = 0;
        while(left < right){    //[)
            mid = left + (right - left)/2;
            if(nums[mid] < target){
                left = mid  + 1;
            }else if(nums[mid] > target){
                right = mid ;
            }else if(nums[mid] == target){
                left = mid + 1 ;
            }
        }
        //System.out.println("nums["+(left-1)+"]=" + " "+nums[left-1]);
        if(left - 1 < 0)  return -1;
        return nums[left-1] == target ?  left -1 :-1;
    }
```







#### 旋转数组问题

>旋转数组一般 只比较 `mid  最右   `（因为  尾巴（最右） 必然是小于等于 头  （最左））两个点  的大小

>```java
>33   // 找指定的taget
>
>public int search(int[] nums, int target) {
>   int left = 0;
>   int right = nums.length -1;
>   int mid = 0;
>   while(left <= right){
>       mid = left +(right - left)/2;
>       // head   必然是大于  tail 的
>       int head = nums[left];
>       int tail = nums[right];
>       if(nums[mid] == target) return mid;
>       //可以明确的是前半部 是升序的
>       else if(nums[mid] >tail){
>           // 就去前半部分寻找  比如  4 5 6 7 8 9 10 11 12 0 1 2 3  找6
>           if(nums[mid]>target &&  head<=target){
>               right = mid -1;
>           // 否则去后半部分查找  比如  4 5 6 7 8 9 10 11 12 0 1 2 3  找12
>           }else{
>               left = mid + 1;
>           }
>       }else {  //可以明确的是  后半部 是升序的
>       // 6 7 0 1 2 3 4 5   找3 
>           if(nums[mid] < target && tail >= target){
>               left = mid +1;
>       // 6 7 0 1 2 3 4 5   找7 
>           }else{
>               right = mid - 1;
>           }
>       }
>   }
>   return -1;
>}
>
>```
>
>```java
>牛客   找最小值  只与尾巴比较
>
>public class Solution {
>public int minNumberInRotateArray(int [] array) {
>   int  right = array.length - 1;
>   int left = 0;
>   int mid = 0;
>   //尾巴 必然是小于等于 头   所以只进行比较 尾巴就可以了
>   while (left <= right) {
>
>       if (left + 1  == right)  return Math.min(array[left], array[right]);
>
>
>       int tail = array[right];
>       mid = (right - left) / 2 + left;
>       if (array[mid] > tail) { //比尾巴还 大
>           left  =  mid;
>       } else if (array[mid] < tail) { //比尾巴还小  说明后面一段肯定是递增的
>           right = mid ;
>       } else { //和尾巴 或者 头 一样大的时候   一个一个尝试
>           // left+=1; 是过不掉 用例  1,0,1,1,1  的  原因是 我们比较的 是结尾节点的 元素(array[right])
>           right -= 1;
>       }
>   }
>   return array[mid];
>}
>}
>```
>
>











## nSum问题



>实际上就是把之前的题目解法合并起来了，`n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举第一个数字，然后递归调用计算 `(n-1)Sum`，组装答案。
>
>**需要注意的是，调用这个 `nSum` 函数之前一定要先给 `nums` 数组排序**，因为 `nSum` 是一个递归函数，如果在 `nSum` 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

```java
//求和模版：
    List<List<Integer>> nSum(int[] nums, long target, int n, int start){
        List<List<Integer>>  res= new ArrayList<>();
        if(n<2 || nums.length < n){
            return res;
        }
        if(n==2){
            int left = start;
            int right = nums.length-1;
            while(left < right){
                int leftval  = nums[left];
                int rightval = nums[right];
                long sum = leftval + rightval;
                if(sum < target){
                    while(left<right && nums[left]==leftval) left++;
                }else if(sum > target){
                    while(left<right && nums[right]==rightval) right--;
                }else if(sum == target){
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list);
                    while(left < right && nums[left] == leftval) left++;
                    while(left < right && nums[right] == rightval) right--;
                }
            }
        }else{
           int i= start;
           while(i<nums.length){
               int now = nums[i];
                List<List<Integer>> lists = nSum(nums,target-now,n-1,i+1);
                for(List<Integer>list : lists){
                    list.add(now);
                    res.add(list);
                }
                while(i<nums.length && nums[i] == now)
                    i++;
            }
        }
        return res;
    }
```

## ==前缀和==

#### 一维数组前缀和

> 就是将 一个数组 前面从  下标`i~j`的多个数进行求和

#### 核心代码

```java
①//用数组存储的形式
int preSum[] = new int(nums.length+1);
for(int i = 1;i<nums.length;i++){
    preSum[i] = preSum[i-1]+nums[i-1];
}

---- 返回某一个 区间的 值
    
return preSum[right + 1] - preSum[left];
//Presum 的 第一位 默认为 0 ;  赋值是从 第二位（i=1）开始的  
//所以是   right + 1



②//不用数组存储的形式  724
int sum =0;
for(int i = 0;i<nums.length;i++){
       sum += nums[i];
}

③//使用map 集合的形式：  560   1248
 		HashMap<Integer, Integer> preSumMap = new HashMap<Integer, Integer>();
        //前缀和map集合 第一位一样为0
        preSumMap.put(0,1);
      	for(int i=0; i<nums.length; i++){
            sum+=nums[i];
            ...
        }
```

#### 原理：

><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241717648.png" alt="image-20230324171756609" style="zoom:25%;" />
>
>
>
>- 这样就能得到一个新的数组`preSum[]  `，这个数组存放的 值 就是前 n  个 数求和的结果
>
>- Presum 的 第一位 默认为 0 ;  赋值是从 第二位`（i=1）`开始的

#### 二维数组前缀和

##### 核心代码

```java
	int [][]preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
                //获得每个矩阵的大小
            }
        }


return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];

```

>==注：==
>	1、` preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];`
>
>- 这是来获得矩阵中每一位的 值，preSum矩阵的 行` i` 列` j`表示  原矩阵  的第`(i-1)`行第`(j-1)`列的元素之和是多少
>
>- 这个公式的含义就是：
>
>![image-20230324164633137](https://gitee.com/Ryang1118/typora/raw/master/images/202303241646207.png)
>
> 将已知的 `矩阵面积[i-1,j]（红色部分）` 和`矩阵面积[i,j-1]（红色部分）`之和 减去 `重叠矩阵面积[i,j-1]（黄色字体部分）` 再加上`原矩阵的当前值matrix[i-1,j-1]`   就是所求得到`原矩阵[i-1,j-1]面积之和`  存放在 `现在矩阵preSum[i][j]`中
>
>**注意：**`i，j`都是以preSum为基准，上图的矩阵是 `matirx`中的矩阵
>
>
>
>2、`preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];`
>
>​	**原理**：<img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241707744.png" alt="image-20230324170718702" style="zoom:25%;" />



```java
// 560   给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 
---- 前缀和变量   +  map   一边加  一边寻找  一遍put 
    public int subarraySum(int[] nums, int k) {
            int n = nums.length;
            HashMap<Integer, Integer> map = new HashMap<>();
            // 第一放 0
            map.put(0, 1);
            int sum  = 0;
            int count = 0;
            for(int i = 0;i<nums.length;i++){
                sum += nums[i];
                //判断map中有没有 sum-k   要是有的话就说明有这个子集
                if(map.containsKey(sum-k)){
                    count+=map.get(sum-k);
                }
                map.put(sum, map.getOrDefault(sum,0)+1);
            }
            
            return count;
----另一种 耗时的写法:
  
    public int subarraySum(int[] nums, int k) {
            int n = nums.length;
            int prefix[] = new int[nums.length+1];
             int count = 0;
            for(int i = 0;i<nums.length;i++){
                prefix[i+1] = prefix[i]+ nums[i];
            }

            for(int i = 0;i<prefix.length;i++){ 
                for(int j = i;j<prefix.length-1;j++){
                    //此处索引偏移
                    if(prefix[j+1]-prefix[i] == k){
                        count++;
                    }
                }
            }
            return count;
    }

    
    
    
    
//1248  给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

---- 前缀和 + 思想转换 + map
---- 奇偶 某种意义上 是等于 0/1 的
    // 同 560 奇数变 1，偶数变 0，然后找区间和为 k（K个1） 的子数组
    public int numberOfSubarrays(int[] nums, int k) {
        int sum = 0;
        int count = 0;
        HashMap<Integer, Integer> preSumMap = new HashMap<Integer, Integer>();
        //前缀和map集合 第一位一样为0
        preSumMap.put(0,1);
        //变更数组
        for(int i=0; i<nums.length; i++){
            if(nums[i]%2 == 0) nums[i] =0;
            else nums[i] =1;
        }
        // 求前缀和为 K 的子集个数
        for(int i=0; i<nums.length; i++){
            sum+=nums[i];
            if(preSumMap.containsKey(sum-k)){
                count+=preSumMap.get(sum-k);
            }
            preSumMap.put(sum,preSumMap.getOrDefault(sum,0)+1);
        }
        return count;
    }
    
    
    
    
//724  数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和
    public int pivotIndex(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        map.put(0,1);
        int left =0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
        }
       for(int i = 0; i<nums.length; i++){
          sum -= nums[i];
          if(sum == left) return i;
          left+=nums[i];
       }
        return -1;
    }
    
------- 另外的解法
        class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        int left = 0;
        for(int  i =0;i<nums.length;i++){
           sum += nums[i];
        }
    //   方式一:判断左端 和 右端 的和
    //     for(int i =0;i<nums.length;i++) {
    //         right = right - nums[i];
    //         if (right == left) return i;
    //         left += nums[i]; 
    //     }
        //方式二： 左端 和 + 中间点  = 总和
          for(int i =0;i<nums.length;i++) {
              //左求和*2+中心索引值 = 总和
            if (left * 2 + nums[i] == sum) return i;
            left += nums[i]; 
        }
        return -1;
    }
}
```

```java
map + 前缀和的模版
    
    
    
public int subarraySum(int[] nums, int k) {
        // k-v k:前缀和（有N个奇数） v：有几种情况
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int count = 0;
        int sum = 0;
    
        for (int num : nums) {
--------模版：      //（sum += num）
    
----------1248     sum+=1; //就是转为0（偶数）/1（奇数）
-------560         sum += num; //724也这么写
            
            
            
------560 1248  能在一个循环的写原因是  每次累加求和 的sum 都要进行比较          
         if (map.containsKey(sum - k)) {
              count += map.get(sum - k);
         }
         map.put(sum, map.getOrDefault(sum,0)+1);
        }
    
//----724 要两次循环  因为在拿到结果之后再进行比较
//    	for(int i= 0;i<nums.length;i++){
//          sum -= nums[i];
//          if(sum == count) return i;
//          count+=nums[i];
//        }
        return count;
    }

```

1248  滑动窗口的解法：

>样例：
>
>```sh
>输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
>输出：16
>```
>
>```java
>class Solution {
>public int numberOfSubarrays(int[] nums, int k) {
>   int left = 0, right = 0, oddCnt = 0, res = 0;
>   while (right < nums.length) {
>       // 右指针先走，每遇到一个奇数则 oddCnt++。
>       if ((nums[right++]  % 2) == 1) {
>           oddCnt++;
>       }
>
>       //  若当前滑动窗口 [left, right) 中有 k 个奇数了，进入此分支统计当前滑动窗口中的优美子数组个数。
>       if (oddCnt == k) {
>           // 先将滑动窗口的右边界向右拓展，直到遇到下一个奇数（或出界）
>           // rightEvenCnt 即为第 k 个奇数右边的偶数的个数
>           int tmp = right;
>           while (right < nums.length && (nums[right] % 2) == 0) {
>               right++;
>           }
>           int rightEvenCnt = right - tmp;
>           // leftEvenCnt 即为第 1 个奇数左边的偶数的个数
>           int leftEvenCnt = 0;
>           while ((nums[left] % 2) == 0) {
>               leftEvenCnt++;
>               left++;
>           }
>           // 第 1 个奇数左边的 leftEvenCnt 个偶数都可以作为优美子数组的起点
>           // (因为第1个奇数左边可以1个偶数都不取，所以起点的选择有 leftEvenCnt + 1 种）
>           // 第 k 个奇数右边的 rightEvenCnt 个偶数都可以作为优美子数组的终点
>           // (因为第k个奇数右边可以1个偶数都不取，所以终点的选择有 rightEvenCnt + 1 种）
>           // 所以该滑动窗口中，优美子数组左右起点的选择组合数为 (leftEvenCnt + 1) * (rightEvenCnt + 1)
>           res += (leftEvenCnt + 1) * (rightEvenCnt + 1);
>
>           // 此时 left 指向的是第 1 个奇数，因为该区间已经统计完了，因此 left 右移一位，oddCnt--
>           left++;
>           oddCnt--;
>       }
>
>   }
>
>   return res;
>}
>}
>```
>
>



## 差分数组

>**主要适用场景** 是频繁对原始数组的**某个区间的元素进行增减**。
>
>总共需要`三个数组`

#### 核心代码

```java
diff[0] = nums[0];  //区别
for(int i= 1;i<nums.length;i++){
    diff[i] = nums[i]-nums[i-1];
} 
```

#### 原理：

><img src="https://gitee.com/Ryang1118/typora/raw/master/images/202303241742451.png" style="zoom:25%;" />
>
>之后就可以经由 差分数组 **反推** 原数组

#### 反推代码

```java
int res[] = new int [diff.length];
res[0] = diff[0];  // 同上 
for(int i = 1; i<diff.length;i++){
    res[i] = res[i-1]+diff[i];
}
```

>如果要对区间 `nums[i..j]` 的元素全部加 3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可
>
>​	**其实 nums[] 和 diff[] 是一样长的，所以下标长度位置也是一样的**，所以直接 j+1

#### 代码组合

```java
// 正推 差分数组
	int[] diff = null;
	public Difference(int[] nums) {
        if( nums.length == 0)  return ;
        
        diff = new int[nums.length];
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
// 反推原数组
 	public int[] result() {
        int[] res = new int[diff.length];
       
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }

//进行增加（+ 正数）、减少（+ 负数）操作
	public void increment(int i, int j, int val) {
        //  diff[i] 加 val   diff是差分数组   意味着从 [i]开始之后的每一个原数组中的数都会+3  就是说，这个加的数是 差值
        diff[i] += val;  
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
            //当 j+1 >= diff.length 时，说明是对 nums[i] 及以后的整个数组都进行修改，那么就不需要再给 diff 数组减 val 了。
        }
    }
```

#### 模版整合

```java
//航班预定统计    +    拼车  
	int diff[];
    int result [];

    public int[] corpFlightBookings(int[][] bookings, int n) {
        
        result = new int [n];
        diff = new int [n];
        if(n == 0 || bookings.length == 0 ) return result;

        // 正推 diff 数组的值
        //diff[0] = nums[0];
        //for(int i = 1; i < n-1; i++){
        	// 某个一维数组 nums
            //diff[i] = nums[i]-nums[i-1];
        //}

        // 循环 且 操作
        for(int []booking :bookings){
            int i = booking[0]-1;
            int j = booking[1]-1;  //-1 是因为下标是从 1 开始的，要是从 0 开始就不用 -1
            int val=booking[2];
            							 //  航班预订统计
            							 //  int j  = trip[2]-1; //坐标范围： 0 <= fromi < toi <= 1000
            													 //但是 在 trip[2]  位置已经下车，在车上的区间就是  [trip[1],trip[2]-1]
           // 进行操作
            diff[i] += val;
            
            //diff.length
            if(j+1<diff.length){
            	diff[j+1] -= val;
        	}
        }

        // 反推 原数组的值
        result[0] = diff[0];
        for(int i=1;i<diff.length;i++){
            result[i] = result[i-1]+diff[i];
            	//拼车时：
            	 if(res[i] > capacity) return false;
        }
        return result;    //return true;
    }
```

## 单调栈

#### 模版

>==注意== 所有入栈的元素全是 数组下标  ` Stack<Integer> stack = new Stack<>();  //存的都是角标`

```java
while(){...见下}
// 最大面积    单调减栈 -----------------------------------数组扩容，收尾 + 0
 // 当前 比 前面的都要 小的栈顶元素
                int mid = res[stack.peek()];
                //System.out.print(mid);
                stack.pop();
                if(!stack.isEmpty()){
                     // 左边第一个比 当前值小 的柱子
                    //int left = res[stack.peek()];
                    //System.out.print(left);
                    // 右边第一个比 当前值小 的柱子
                    //int right = res[i];
                    //System.out.print(right);
                    // 左右最小柱子之间的 间隔 底
                    int len = i-stack.peek()-1;
                    //System.out.print(len);
                    // 以当前柱子为 高 算得 最 大面积
                    result= Math.max(result,mid*len);
                    //System.out.print(result);
                }

```

>==496  下一个更大数 I==
>
>```java
>int result[];
>int []res;
>public int[] nextGreaterElement(int[] nums1, int[] nums2) {
>
>   res = new int[nums2.length];
>   Arrays.fill(res,-1);
>   result  = new int[nums1.length];
>   Stack<Integer> stack = new Stack<>();
>   HashMap<Integer, Integer> map = new HashMap<>();
>   //先将 第 0 个 元素加入到栈，防止栈空 
>   stack.push(0);
>   for (int i = 0; i < nums2.length; i++) {
>       //单调递增栈
>       while(!stack.isEmpty() && nums2[i]>nums2[stack.peek()]) {
>           res[stack.peek()] = nums2[i];
>           stack.pop();
>       }
>       stack.push(i);
>   }
>
>   for (int i = 0; i < nums2.length; i++) {
>       map.put(nums2[i],res[i]);
>   }
>   for (int i = 0; i < nums1.length; i++) {
>       result[i]= map.get(nums1[i]);
>   }
>
>   return result;
>}
>```
>
>
>
>==503 下一个更大数 II==
>
>==环形数组处理方法==  % 取余  加长数组长度，使数组长 * 2   之后对所有的i 相关操作 % nums.length
>
>```java
>int res[];
>int result[];
>public int[] nextGreaterElements(int[] nums) {
>   res = new int[2 * nums.length];
>   result = new int[nums.length];
>   Arrays.fill(res,-1);
>   Stack<Integer> stack = new Stack<>();
>   stack.push(0);
>   for (int i = 1; i <2 * nums.length; i++) {
>       while(!stack.isEmpty() && nums[i%nums.length] > nums[stack.peek()]) {
>           res[stack.peek()] = nums[i%nums.length];
>           stack.pop();
>       }
>       stack.push(i%nums.length);
>   }
>  for (int i = 0; i < nums.length; i++) {
>       result[i] = res[i];
>   }
>   return result;
>}
>```
>
>==739  每日温度  下一个大的数的角标==
>
>```java
>public int[] dailyTemperatures(int[] temperatures) {
>   int []res  = new int [temperatures.length];
>   Stack<Integer> stack = new Stack<>();  //存的都是角标
>   // 首先把数组的 第一个元素入栈，随后才能比较
>   stack.push(0);
>   for(int  i = 1;i < temperatures.length;i++){
>       // 这里 temperatures[i]>temperatures[stack.peek()]  大于  就是单调增 栈
>       //       			  <							   小于  就是单调减 栈
>       while(!stack.isEmpty() && temperatures[i]>temperatures[stack.peek()]){
>           // 返回下标之间的差值
>           res[stack.peek()] = i - stack.peek();   
>           // 返回下标对应的值
>           //res[stack.peek()] = nums2[i];     两个数组的话可以用map进行接收 
>           stack.pop();
>       }  
>       stack.push(i);      
>   }
>   return res;
>}
>```
>
>==42接雨水==
>
>```java
>public int trap(int[] height) {
>   int res [] = new int[height.length];
>   Stack<Integer> stack = new Stack<>();
>   stack.push(0);
>   int sum = 0 ;
>   for(int i = 1; i < height.length;i++) {
>       while(!stack.isEmpty() && height[i] > height[stack.peek()]) {
>        // 接雨水    单调增栈
>           int mid = height[stack.peek()];
>           // 出栈
>           stack.pop();
>           if(!stack.isEmpty()){
>               // 左边第一个高的   就是栈里面 凹槽值 的下一个
>               int left =height[stack.peek()];
>               // 右边第一个高的   就是当前要进栈的值
>               int right =height[i];
>               // 底
>               int len = i-stack.peek()-1;  //-1
>               // 高
>               int hei = Math.min(left,right)-mid;
>               //面积 = 底*高
>               sum +=  hei*len;
>           }
>        }
>          stack.push(i);
>       }
>        return sum;
>}
>```
>
>
>
>==84一维最大面积==
>
>```java
>class Solution {
>public int largestRectangleArea(int[] heights) {
>   // 思路是 算出每个柱子为高的最大面积 比较大小
>   int res[] = new int[heights.length +2];
>   int result= 0;
>   //收尾加0 防止特殊情况 <=
>   for (int i = 1; i <= heights.length; i++) {
>      res[i] = heights[i-1];
>   }
>
>   //单调递减栈
>   Stack<Integer> stack = new Stack<>();
>   stack.push(0);
>   for (int i = 1; i < res.length; i++) {
>       while(!stack.isEmpty() && res[i] < res[stack.peek()]) {
>           // 当前 比 前面的都要 小的栈顶元素
>           int mid = res[stack.peek()];
>           //System.out.print(mid);
>           stack.pop();
>           if(!stack.isEmpty()){
>                // 左边第一个比 当前值小 的柱子
>               //int left = res[stack.peek()];
>
>               // 右边第一个比 当前值小 的柱子
>               //int right = res[i];
>
>               // 左右最小柱子之间的 间隔 底
>               int len = i-stack.peek()-1;
>
>               // 以当前柱子为 高 算得 最 大面积
>               result= Math.max(result,mid*len);
>
>           }
>
>       }
>       stack.push(i);
>   }
>   return result;
>}
>}
>```
>
>
>
>==85 二维最大面积==
>
>```java
>
>public int maximalRectangle(char[][] matrix) {
>int  m = matrix.length;
>int  n = matrix[0].length;
>int height[] = new int[n];
>int res = 0;
>  for(int  i = 0; i < m;i++){
>      for(int j = 0;j < n;j++){
>          if(matrix[i][j]=='1')
>              height[j] +=1;
>          else
>              height[j] = 0;
>      }
>       // 每一层都进行 求面积  和 对面积的比较
>       res = Math.max(res,largestRectangleArea(height));
>  }
>return res;
>}
>
>
>
>
>  public int largestRectangleArea(int[] heights) {
>       // 思路是 算出每个柱子为高的最大面积 比较大小
>       int res[] = new int[heights.length +2];
>       int result= 0;
>       //收尾加0 防止特殊情况 <=
>       for (int i = 1; i <= heights.length; i++) {
>          res[i] = heights[i-1];
>       }
>
>       //单调递减栈
>       Stack<Integer> stack = new Stack<>();
>       stack.push(0);
>       for (int i = 1; i < res.length; i++) {
>           while(!stack.isEmpty() && res[i] < res[stack.peek()]) {
>               // 当前 比 前面的都要 小的栈顶元素
>               int mid = res[stack.peek()];
>               //System.out.print(mid);
>               stack.pop();
>               if(!stack.isEmpty()){
>                    // 左边第一个比 当前值小 的柱子
>                   //int left = res[stack.peek()];
>
>                   // 右边第一个比 当前值小 的柱子
>                   //int right = res[i];
>
>                   // 左右最小柱子之间的 间隔 底
>                   int len = i-stack.peek()-1;
>
>                   // 以当前柱子为 高 算得 最 大面积
>                   result= Math.max(result,mid*len);
>
>               }
>
>           }
>           stack.push(i);
>       }
>       return result;
>   }
>}
>```
>
>

















## 字典树

#### 应用场景：处理字符串前缀相关

#### 基本介绍

```java
TrieMap中的树节点TrieNode的代码实现是这样

TrieMap<V>的键必须是字符串类型，值的类型V可以随意
    
/* Trie 树节点实现 */
class TrieNode<V> {
    V val = null;
    TrieNode<V>[] children = new TrieNode[256];
}

val字段存储键对应的值，children数组存储指向子节点的指针。
    
TrieNode中children数组的索引是有意义的，代表键中的一个字符。
比如说children[97]如果非空，说明这里存储了一个字符'a'，因为'a'的 ASCII 码为 97。
    
TrieNode节点本身只存储val字段，并没有一个字段来存储字符，字符是通过子节点在父节点的children数组中的索引确定的
    

```

>==Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。==

#### API

```java
TreeMap API 
    
// 底层用 Trie 树实现的键值映射
// 键为 String 类型，值为类型 V
class TrieMap<V> {

    /***** 增/改 *****/

    // 在 Map 中添加 key
    public void put(String key, V val);

    /***** 删 *****/

    // 删除键 key 以及对应的值
    public void remove(String key);

    /***** 查 *****/

    // 搜索 key 对应的值，不存在则返回 null
    // get("the") -> 4
    // get("tha") -> null
    public V get(String key);

    // 判断 key 是否存在在 Map 中
    // containsKey("tea") -> false
    // containsKey("team") -> true
    public boolean containsKey(String key);

    // 在 Map 的所有键中搜索 query 的最短前缀
    // shortestPrefixOf("themxyz") -> "the"
    public String shortestPrefixOf(String query);

    // 在 Map 的所有键中搜索 query 的最长前缀
    // longestPrefixOf("themxyz") -> "them"
    public String longestPrefixOf(String query);

    // 搜索所有前缀为 prefix 的键
    // keysWithPrefix("th") -> ["that", "the", "them"]
    public List<String> keysWithPrefix(String prefix);

    // 判断是和否存在前缀为 prefix 的键
    // hasKeyWithPrefix("tha") -> true
    // hasKeyWithPrefix("apple") -> false
    public boolean hasKeyWithPrefix(String prefix);

    // 通配符 . 匹配任意字符，搜索所有匹配的键
    // keysWithPattern("t.a.") -> ["team", "that"]
    public List<String> keysWithPattern(String pattern);

    // 通配符 . 匹配任意字符，判断是否存在匹配的键
    // hasKeyWithPattern(".ip") -> true
    // hasKeyWithPattern(".i") -> false
    public boolean hasKeyWithPattern(String pattern);

    // 返回 Map 中键值对的数量
    public int size();
    
}
```

#### API实现

>`TrieMap`类中一定需要记录 Trie 的根节点`root`，以及 Trie 树中的所有节点数量用于实现`size()`方法

##### 实现`containsKey`方法和`get`方法

>**就算`getNode(key)`的返回值`x`非空，也只能说字符串`key`是一个「前缀」；除非`x.val`同时非空，才能判断键`key`存在**。

##### 实现`shortestPrefixOf`方法

>**这里需要注意的是 for 循环结束之后我们还需要额外检查一下**。
>
>因为之前说了 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即`key`本身就是`TrieMap`中的一个键的情况。

##### 实现 `longestPrefixOf `方法

>每次遇到`p.val`非空的时候说明找到一个键，但是我们不急着返回，而是更新`max_len`变量，记录最长前缀的长度。
>
>同样的，在 for 循环结束时还是要特殊判断一下，处理`key`本身就是键的情况。

##### 实现`keysWithPrefix`方法

> 得到所有前缀为`prefix`的键:先利用`getNode`函数在 Trie 树中找到`prefix`对应的节点`x`，然施展多叉树的遍历算法，遍历以`x`为根的这棵 Trie 树，找到所有键值对：

##### 实现`keysWithPattern`方法

>使用通配符来匹配多个键，其关键就在于通配符`.`可以匹配所有字符

>`keysWithPattern`和`keysWithPrefix`的实现是有些类似的，而且这两个函数还有一个潜在的特性：**它们返回的结果列表一定是符合「字典序」的**。

##### 实现`hasKeyWithPattern`方法

>判断是否存在键匹配模式串

##### 实现`put`方法

>**Trie 树中的键就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把`key`的整条「树枝」构建出来之后，在树枝末端的「节点」中存储`val`**：

##### 实现`remove`函数

>如果你想删除键`"team"`，那么需要删掉`"eam"`这条树枝才是符合逻辑的;删多了肯定不行，但删少了也不行，否则前文实现的`hasKeyWithPrefix`就会出错。
>
>
>
>首先，递归修改数据结构的时候，如果一个节点想删掉自己，直接返回空指针就行了。
>
>**其次，一个节点如何知道自己是否需要被删除呢？主要看自己的`val`字段是否为空以及自己的`children`数组是否全都是空指针**。
>
>**一个节点如何知道自己是否需要被删除呢？主要看自己的`val`字段是否为空以及自己的`children`数组是否全都是空指针**。
>
>
>
>==后序位置的特点==
>
>一个节点要先递归处理子树，然后在后序位置检查自己的`val`字段和`children`列表，判断自己是否需要被删除。
>
>如果自己的`val`字段为空，说明自己没有存储值，如果同时自己的`children`数组全是空指针，说明自己下面也没有接树枝，即不是任何一个键的前缀。这种情况下这个节点就没有存在的意义了，应该删掉自己。



##### `TrieMap`完整API

```java
class TrieMap<V> {
    // ASCII 码个数
    private static final int R = 256;
    // 当前存在 Map 中的键值对个数
    private int size = 0;
    // Trie 树的根节点
    private TrieNode<V> root = null;

    private static class TrieNode<V> {
        V val = null;
        TrieNode<V>[] children = new TrieNode[R];
    }

    /***** 增/改 *****/

    // 在 map 中添加或修改键值对
    public void put(String key, V val) {
        if (!containsKey(key)) {
            // 新增键值对
            size++;
        }
        // 需要一个额外的辅助函数，并接收其返回值
        root = put(root, key, val, 0);
    }

    // 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点
    private TrieNode<V> put(TrieNode<V> node, String key, V val, int i) {
        if (node == null) {
            // 如果树枝不存在，新建
            node = new TrieNode<>();
        }
        if (i == key.length()) {
            // key 的路径已插入完成，将值 val 存入节点
            node.val = val;
            return node;
        }
        char c = key.charAt(i);
        // 递归插入子节点，并接收返回值
        node.children[c] = put(node.children[c], key, val, i + 1);
        return node;
    }

    /***** 删 *****/

    // 在 Map 中删除 key
    public void remove(String key) {
        if (!containsKey(key)) {
            return;
        }
        // 递归修改数据结构要接收函数的返回值
        root = remove(root, key, 0);
        size--;
    }

    // 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点
    private TrieNode<V> remove(TrieNode<V> node, String key, int i) {
        if (node == null) {
            return null;
        }
        if (i == key.length()) {
            // 找到了 key 对应的 TrieNode，删除 val
            node.val = null;
        } else {
            char c = key.charAt(i);
            // 递归去子树进行删除
            node.children[c] = remove(node.children[c], key, i + 1);
        }
        // 后序位置，递归路径上的节点可能需要被清理
        if (node.val != null) {
            // 如果该 TireNode 存储着 val，不需要被清理
            return node;
        }
        // 检查该 TrieNode 是否还有后缀
        for (int c = 0; c < R; c++) {
            if (node.children[c] != null) {
                // 只要存在一个子节点（后缀树枝），就不需要被清理
                return node;
            }
        }
        // 既没有存储 val，也没有后缀树枝，则该节点需要被清理
        return null;
    }

    /***** 查 *****/

    // 搜索 key 对应的值，不存在则返回 null
    public V get(String key) {
        // 从 root 开始搜索 key
        TrieNode<V> x = getNode(root, key);
        if (x == null || x.val == null) {
            // x 为空或 x 的 val 字段为空都说明 key 没有对应的值
            return null;
        }
        return x.val;
    }

    // 判断 key 是否存在在 Map 中
    public boolean containsKey(String key) {
        return get(key) != null;
    }

    // 判断是和否存在前缀为 prefix 的键
    public boolean hasKeyWithPrefix(String prefix) {
        // 只要能找到一个节点，就是存在前缀
        return getNode(root, prefix) != null;
    }

    // 在所有键中寻找 query 的最短前缀
    public String shortestPrefixOf(String query) {
        TrieNode<V> p = root;
        // 从节点 node 开始搜索 key
        for (int i = 0; i < query.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                return "";
            }
            if (p.val != null) {
                // 找到一个键是 query 的前缀
                return query.substring(0, i);
            }
            // 向下搜索
            char c = query.charAt(i);
            p = p.children[c];
        }

        if (p != null && p.val != null) {
            // 如果 query 本身就是一个键
            return query;
        }
        return "";
    }

    // 在所有键中寻找 query 的最长前缀
    public String longestPrefixOf(String query) {
        TrieNode<V> p = root;
        // 记录前缀的最大长度
        int max_len = 0;

        // 从节点 node 开始搜索 key
        for (int i = 0; i < query.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                break;
            }
            if (p.val != null) {
                // 找到一个键是 query 的前缀，更新前缀的最大长度
                max_len = i;
            }
            // 向下搜索
            char c = query.charAt(i);
            p = p.children[c];
        }

        if (p != null && p.val != null) {
            // 如果 query 本身就是一个键
            return query;
        }
        return query.substring(0, max_len);
    }

    // 搜索前缀为 prefix 的所有键
    public List<String> keysWithPrefix(String prefix) {
        List<String> res = new LinkedList<>();
        // 找到匹配 prefix 在 Trie 树中的那个节点
        TrieNode<V> x = getNode(root, prefix);
        if (x == null) {
            return res;
        }
        // DFS 遍历以 x 为根的这棵 Trie 树
        traverse(x, new StringBuilder(prefix), res);
        return res;
    }

    // 遍历以 node 节点为根的 Trie 树，找到所有键
    private void traverse(TrieNode<V> node, StringBuilder path, List<String> res) {
        if (node == null) {
            // 到达 Trie 树底部叶子结点
            return;
        }

        if (node.val != null) {
            // 找到一个 key，添加到结果列表中
            res.add(path.toString());
        }

        // 回溯算法遍历框架
        for (char c = 0; c < R; c++) {
            // 做选择
            path.append(c);
            traverse(node.children[c], path, res);
            // 撤销选择
            path.deleteCharAt(path.length() - 1);
        }
    }

    // 通配符 . 匹配任意字符
    public List<String> keysWithPattern(String pattern) {
        List<String> res = new LinkedList<>();
        traverse(root, new StringBuilder(), pattern, 0, res);
        return res;
    }

    // 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]
    private void traverse(TrieNode<V> node, StringBuilder path, String pattern, int i, List<String> res) {
        if (node == null) {
            // 树枝不存在，即匹配失败
            return;
        }
        if (i == pattern.length()) {
            // pattern 匹配完成
            if (node.val != null) {
                // 如果这个节点存储着 val，则找到一个匹配的键
                res.add(path.toString());
            }
            return;
        }
        char c = pattern.charAt(i);
        if (c == '.') {
            // pattern[i] 是通配符，可以变化成任意字符
            // 多叉树（回溯算法）遍历框架
            for (char j = 0; j < R; j++) {
                path.append(j);
                traverse(node.children[j], path, pattern, i + 1, res);
                path.deleteCharAt(path.length() - 1);
            }
        } else {
            // pattern[i] 是普通字符 c
            path.append(c);
            traverse(node.children[c], path, pattern, i + 1, res);
            path.deleteCharAt(path.length() - 1);
        }
    }

    // 判断是和否存在前缀为 prefix 的键
    public boolean hasKeyWithPattern(String pattern) {
        // 从 root 节点开始匹配 pattern[0..]
        return hasKeyWithPattern(root, pattern, 0);
    }

    // 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配
    private boolean hasKeyWithPattern(TrieNode<V> node, String pattern, int i) {
        if (node == null) {
            // 树枝不存在，即匹配失败
            return false;
        }
        if (i == pattern.length()) {
            // 模式串走到头了，看看匹配到的是否是一个键
            return node.val != null;
        }
        char c = pattern.charAt(i);
        // 没有遇到通配符
        if (c != '.') {
            // 从 node.children[c] 节点开始匹配 pattern[i+1..]
            return hasKeyWithPattern(node.children[c], pattern, i + 1);
        }
        // 遇到通配符
        for (int j = 0; j < R; j++) {
            // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回
            if (hasKeyWithPattern(node.children[j], pattern, i + 1)) {
                return true;
            }
        }
        // 都没有匹配
        return false;
    }

    
    
    // 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null
    private TrieNode<V> getNode(TrieNode<V> node, String key) {
        TrieNode<V> p = node;
        // 从节点 node 开始搜索 key
        for (int i = 0; i < key.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                return null;
            }
            // 向下搜索
            char c = key.charAt(i);
            p = p.children[c];
        }
        return p;
    }

    public int size() {
        return size;
    }
}
```

##### `TrieSet`完整API

```java
class TrieSet {
    // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用
    // 值的类型可以随便设置，我参考 Java 标准库设置成 Object
    private final TrieMap<Object> map = new TrieMap<>();

    /***** 增 *****/

    // 在集合中添加元素 key
    public void add(String key) {
        map.put(key, new Object());
    }

    /***** 删 *****/

    // 从集合中删除元素 key
    public void remove(String key) {
        map.remove(key);
    }

    /***** 查 *****/

    // 判断元素 key 是否存在集合中
    public boolean contains(String key) {
        return map.containsKey(key);
    }

    // 在集合中寻找 query 的最短前缀
    public String shortestPrefixOf(String query) {
        return map.shortestPrefixOf(query);
    }

    // 在集合中寻找 query 的最长前缀
    public String longestPrefixOf(String query) {
        return map.longestPrefixOf(query);
    }

    // 在集合中搜索前缀为 prefix 的所有元素
    public List<String> keysWithPrefix(String prefix) {
        return map.keysWithPrefix(prefix);
    }

    // 判断集合中是否存在前缀为 prefix 的元素
    public boolean hasKeyWithPrefix(String prefix) {
        return map.hasKeyWithPrefix(prefix);
    }

    // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素
    public List<String> keysWithPattern(String pattern) {
        return map.keysWithPattern(pattern);
    }

    // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素
    public boolean hasKeyWithPattern(String pattern) {
        return map.hasKeyWithPattern(pattern);
    }

    // 返回集合中元素的个数
    public int size() {
        return map.size();
    }
}
```

>==函数的调用关系==
>
>==增/改==    **put** –>**containsKey**、**put**<递归>
>
>==删==    **remove**->**containsKey**、**remove** <递归>
>
>==查==    **get**-> **getNode**
>
>==是否存在==     **containsKey**-> **get**
>
>==是否存在前缀为 prefix 的键==   **hasKeyWithPrefix**->**getNode**
>
>==是否存在符合的通配符的键==  **hasKeyWithPattern**  <递归>
>
>==最短前缀==       **shortestPrefixOf**
>
>==最长前缀==       **longestPrefixOf**
>
>==搜索前缀为 prefix 的所有键==    **keysWithPrefix**->**getNode** 、 **traverse**<递归>
>
>==通配符 . 匹配任意字符==       **keysWithPattern**-> **traverse**<递归>
>
>==从节点 node 开始搜索 key，如果存在返回对应节点==   **getNode **
>
>==大小==       **size**



## 分治

>本质：  也是递归

>**1、不要思考整体，而是把目光聚焦局部，只看一个运算符**。
>
>比如 [手把手刷二叉树第一期](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/) 就告诉你解决二叉树系列问题只要思考每个节点需要做什么，而不要思考整棵树需要做什么。
>
>说白了，解决递归相关的算法问题，就是一个化整为零的过程，你必须瞄准一个小的突破口，然后把问题拆解，大而化小，利用递归函数来解决。
>
>**2、明确递归函数的定义是什么，相信并且利用好函数的定义**。
>
>这个函数不就是干这个事儿的吗？**这就是我们之前说的第二个关键点，明确函数的定义，相信并且利用这个函数定义**。
>
>你甭管这个函数怎么做到的，你相信它能做到，然后用就行了，最后它就真的能做到了。
>
>

```java
   // 结果集接收
        List<Integer> res= new LinkedList<Integer>();
        // 优化
        HashMap<String, List<Integer>> meno = new HashMap<>();
        if(meno.containsKey(expression)){
            return meno.get(expression);
        }


        //分治
        // 分（递归）
       for(int i=1; i<expression.length(); i++) {
            char c = expression.charAt(i);
             //题设只有三种运算符
           // 如果是运算符就 继续进行缩减
            if(c=='-' || c=='+' || c=='*'){
                List<Integer> left = diffWaysToCompute(expression.substring(0,i));
                List<Integer> right = diffWaysToCompute(expression.substring(i+1));
       //治（怎么做）
                for(int a:left) {
                    for(int b:right){
                        if(c =='-')
                            res.add(a-b);
                        else if(c == '+')
                            res.add(a+b);
                        else
                            res.add(a*b);
                    }
                }
            }
       }
        // 递归截止条件
        if(res.isEmpty()){
            res.add(Integer.parseInt(expression));
        }

        return res;
```



## 手撕 LRU



```java
public class LRUCache {
    
    int capacity;
    
    LinkedHashMap<Integer,Integer> map = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.capacity = capacity;
    }
    
    
    //表示访问
    public int get(int key){
        if(!map.containsKey(key)){
            return  -1;
        }
    //移至表尾
        changeSwap(key);
        return map.get(key);
    }
    
    

    //表示添加
    public void put(int key, int value) {
        if(map.containsKey(key)){
            //值的替换
            map.put(key, value);
    //移到表尾
            changeSwap(key);
            return;
        }
        // 超出预设值 删除表头
        if(map.size() > capacity){
            int first = map.keySet().iterator().next();
            map.remove(first);
        }
        //直接添加到表尾即可
        map.put(key, value);
    }

    public void  changeSwap(int key){
        // 找到对应的元素
        int val = map.get(key);
        //随后进行删除
        map.remove(key);
        //再将其加到表尾
        map.put(key,val);
    }
}
```





## 栈实现队列

```java
class MyQueue {

    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();
    public MyQueue() {
        
    }

    public void push(int x) {
        //只管入栈就可以了
        stack1.push(x);
    }


    public int peek() {
        //入栈结束之后，栈2 为空才会进行从栈1 进栈，直到栈1 为空
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    public int pop() {
        // 防止栈2 为空
        if(stack2.isEmpty()){
            peek();
        }
        return stack2.pop();
    }

    public boolean empty() {
        //要两个栈一起为空的时候才为空，否则可能会因为没有pop操作导致一空一非空
        return stack2.isEmpty() && stack1.isEmpty();
    }
}
```



## 队列实现栈

```java
两个队列
class MyStack {
    Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();
    public MyStack() {

    }

   //  需要进行交换
    public void push(int x) {
        queue1.offer(x);
        while(!queue2.isEmpty()){
            queue1.offer(queue2.poll());
        }
         //第一遍的时候不会进行while()循环
        Queue<Integer> tmp = queue2;
        queue2 = queue1;
        queue1 =tmp;

    }

    public int top() {
        return queue2.peek();
    }


    public int pop() {
        return queue2.poll();
    }

    public boolean empty() {
        return queue2.isEmpty();
    }
}
/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
    
    
    
单个队列

class MyStack {
    Queue<Integer> queue = new LinkedList<>();

    public MyStack() {

    }

    //  需要进行交换
    public void push(int x) {
        int n = queue.size();
        queue.offer(x);
        for (int i = 0; i <n; i++) {
            queue.offer(queue.poll());
        }

    }

    public int top() {
        return queue.peek();
    }


    public int pop() {
    return queue.poll();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```



>==通解   （两个栈  、 队列）==
>
>```java
>class MyStack {
>Queue<Integer> queue1 = new LinkedList<>();
>Queue<Integer> queue2 = new LinkedList<>();
>public MyStack() {
>
>}
>
>//  需要进行交换   				队列-->栈
>public void push(int x) {
>   queue1.offer(x);
>   while(!queue2.isEmpty()){
>       queue1.offer(queue2.poll());
>   }
>
>   while(!queue1.isEmpty()){
>       queue2.offer(queue1.poll());
>   }
>
>}
>
>public int top() {
>   return queue2.peek();
>}
>
>
>public int pop() {
>   return queue2.poll();
>}
>
>public boolean empty() {
>   return queue2.isEmpty();
>}
>}
>
>
>
>```
>
>```java
>class MyQueue {
>
>Stack<Integer> stack1 = new Stack<>();
>Stack<Integer> stack2 = new Stack<>();
>
>public MyQueue() {
>
>}
>
>public void push(int x) {
>
>   // 栈转队列
>   while(!stack2.isEmpty()){
>       stack1.push(stack2.pop());
>   }
>
>   stack1.push(x);
>
>   while(!stack1.isEmpty()){
>       stack2.push(stack1.pop());
>   }
>}
>
>public int pop() {
>   return stack2.pop();
>
>}
>
>public int peek() {
>   return stack2.peek();
>}
>
>public boolean empty() {
>   return  stack2.isEmpty();
>}
>}
>
>/**
>* Your MyQueue object will be instantiated and called as such:
>* MyQueue obj = new MyQueue();
>* obj.push(x);
>* int param_2 = obj.pop();
>* int param_3 = obj.peek();
>* boolean param_4 = obj.empty();
>*/
>```
>
>



## 二叉树公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
         if(root == null) return null;
        if(root == p  || root == q) return root;
        TreeNode left  = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left != null && right != null) return root;
        if(left == null  && right == null) return null;
        return right == null? left : right; 
    }
}



//要是二叉搜索树的话还有这样的一种写法，因为  二叉搜索树是有序的
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode cur = root;
        while(p.val < cur.val && q.val < cur.val || p.val >cur.val && q.val > cur.val){
            if(p.val < cur.val){
                cur = cur.left;
            }else{
                cur = cur.right;
            }
        }
        return cur;
    }
}
```

## 手撕快排

```java
//手撕快排
class Quick{
    public static void sort(int nums[]){
        int low = 0;
        int high = nums.length-1;
        shuffle(nums);
        sortQuick(nums,low,high);

    }

    private static void sortQuick(int[] nums, int low, int high) {
        if(low  >= high) return ;
        //获取坐标
        int  mid = partitions(nums,low,high);
        sortQuick(nums,low,mid-1);
        sortQuick(nums,mid+1,high);
    }

    private static int partitions(int[] nums, int low, int high) {
        int pivot = nums[low];
        int left = low+1;
        int right = high;
        while(left <= right){
            while(left < high && nums[left] <= pivot){
                left++;
            }
            while(right> low && nums[right] > pivot){
                right--;
            }
            if(left >= right) break;
            swap(nums,left,right);
        }
        // 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大
        swap(nums,low,right);
        return right;
    }

    private static void swap(int[] nums, int left, int right) {
        int tmp  = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
    }

    private static void shuffle(int[] nums) {
        Random random = new Random();
        int n = nums.length;
        for(int i = 0; i < n; i++){
            int t = i + random.nextInt(n-i);
            swap(nums,i,t);
        }
    }
}
```

## 手撕二叉堆实现优先级队列

```java
class Priority_Queue<T extends Comparable<T>>{
    T[] pq;
    int size = 0;
    Priority_Queue(int capacity) {
        pq = (T[]) new Comparable[capacity +1];
    }
    public T max(){
        return pq[1];
    }
    public void insert(T e){
        size++;
        // 先把新元素加到最后
        pq[size] = e;
        // 然后让它上浮到正确的位置
        swim(size);
    }
    public T delMax(){
        T max = pq[1];
        // 把这个最大元素换到最后，删除之
        swap(1, size);
        pq[size] = null;
        size--;
        // 让 pq[1] 下沉到正确位置
        sink(1);
        return max;

    }
    void swim(int x){
        while(x > 1 && less(parent(x),x )){
            swap(parent(x),x );
            x = parent(x);

        }
    }
    void sink(int x){
        while(left(x) <= size){
            int max = left(x);
            if(right(x) <= size && less(max,right(x))) break;
            swap(x,max);
            x= max;
        }
    }
    void swap(int i, int j){
        T temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }
    boolean less(int i, int j){
        return pq[i].compareTo(pq[j]) < 0;
    }

    // 父节点的索引
    int parent(int root) {
        return root / 2;
    }
    // 左孩子的索引
    int left(int root) {
        return root * 2;
    }
    // 右孩子的索引
    int right(int root) {
        return root * 2 + 1;
    }

}

```













## 图

#### 前置： 图论基础

>`图节点的逻辑结构  `      ——和多叉树节点几乎完全一样

>而是用常说的**邻接表和邻接矩阵**来实现

```java
// 邻接表     
    我把每个节点 x 的邻居都存到一个列表里，然后把 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。
// graph[x] 存储 x 的所有邻居节点
        
        
List<Integer>[] graph;





// 邻接矩阵
邻接矩阵则是一个二维布尔数组，我们权且称为 matrix，如果节点 x 和 y 是相连的，那么就把 matrix[x][y] 设为 true（上图中绿色的方格代表 true）。如果想找节点 x 的邻居，去扫一圈 matrix[x][..] 就行了
// matrix[x][y] 记录 x 是否有一条指向 y 的边
    
    
boolean[][] matrix;
```

>==有向加权图==
>如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，
>如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，
>
>```java
>// 邻接表
>// graph[x] 存储 x 的所有邻居节点以及对应的权重
>List<int[]>[] graph;
>
>// 邻接矩阵
>// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
>int[][] matrix;
>
>
>```



>==无向图==
>所谓的「无向」，等同于「双向」
>如果连接无向图中的节点 x 和 y，把 `matrix[x][y]` 和 `matrix[y][x]` 都变成 true 就行了；
>
>邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。

#### 图的遍历

###### 多叉树的 DFS 遍历框架如下

```java
   /* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;
    // 前序位置
    for (TreeNode child : root.children) {
        traverse(child);
    }
    // 后序位置
}
```

###### 图的遍历

图  与 树 的最大区别就是  图可能==有环==

**有环**  时候就需要一个 `visited` 数组进行辅助

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径
boolean[] onPath;

/* 图遍历框架 */
//  过程就是：判断是否已经遍历过，有的话就返回，没有的话就将其置为 遍历过并加到 路径数组中，再循环遍历邻居节点，最后再从 路径节点中删去
void traverse(Graph graph, int s) {
    
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        if (!visited[s])
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}

```

>如果让你处理**路径相关**的问题，这个 `onPath` 变量是肯定会被用到的，比如 [拓扑排序](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/) 中就有运用。
>
>另外，这个 `onPath` 数组的操作很像前文 [回溯算法核心套路](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 `onPath` 数组的操作在 for 循环外面。

#### DFS VS 回溯

> 对于这里「图」的遍历，我们应该用 DFS 算法，即把 `onPath` 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。

###### 代码区别

```java
// DFS 算法，关注点在节点
void traverse(TreeNode root) {
    if (root == null) return;
    printf("进入节点 %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("离开节点 %s", root);
}


// 回溯算法，关注点在树枝
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // 做选择
        printf("从 %s 到 %s", root, child);
        backtrack(child);
        // 撤销选择
        printf("从 %s 到 %s", child, root);
    }
```

>所以对于「图」的遍历，我们应该用 DFS 算法，即把 `onPath` 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。
>
>再说下 `visited` 数组，其目的很明显了，由于图可能含`有环`，`visited` 数组就是防止递归重复遍历同一个节点进入死循环的。
>
>
>
>路径相关的问题，这个 `onPath` 变量是肯定会被用到的，比如 [拓扑排序](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/) 中就有运用。
>
>如果题目告诉你图中不含环，可以把 `visited` 数组都省掉，基本就是多叉树的遍历。





#### 有向无环图的遍历

>==思路1、区别于回溯的写法==
>
>1、定义结果集
>
>2、定义路径集  -> dfs -> return
>
>3、dfs: 做选择   –> 循环结束条件  ->  遍历相邻节点 -> 撤销选择

```java
	//接收结果集
    List<List<Integer>> result = new LinkedList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer> path =  new LinkedList<>();
        traverse(graph,0,path);
        return result;
    }

    void  traverse (int[][] graph,int s,LinkedList<Integer> path) {
        //加到路径中    做选择
        path.add(s);

        //循环结束条件
        int n = graph.length;
        if(s== n-1)  result.add(new LinkedList<>(path));
       
        //dfs
        for(int i: graph[s]){
            traverse(graph,i,path);
        }
        // 撤销选择
        path.removeLast();
    }
```

>拓展内容
>
>BFS
>
>```java
>List<List<Integer>> res = new ArrayList<>();
>public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
>   bfs(graph,0);
>   return res;
>}
>
>private void bfs(int[][] graph, int i) {
>   Queue<List<Integer>> queue = new LinkedList<>();
>   queue.offer(new ArrayList<Integer>(){
>       {
>           add(i);
>       }
>   });
>   while(!queue.isEmpty()) {
>       List<Integer> out = queue.poll();
>       int curNode = out.get(out.size() - 1);
>       for (int j : graph[curNode]) {
>           out.add(j);
>           if(i == graph.length - 1) {
>               res.add(new ArrayList<>(out));
>           }else{
>               queue.offer(new ArrayList<>(out));
>           }
>           out.remove(out.size()-1);
>       }
>   }
>}
>```



>###### 略>
>
>==思路二：类似于回溯的写法==
>
>1、 定义结果集 和 路径变量
>
>2、为避免  漏掉记录起始点的遍历   所以要先将 0 加到path 中
>
>3、**dfs<此处是和回溯一样的>**
>
>```java
>List<List<Integer>> result = new LinkedList<>();
>LinkedList<Integer> path =  new LinkedList<>();
>
>public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
>   path.add(0);
>   dfs(graph,0);
>   return result;
>}
>
>void  dfs (int[][] graph,int s) {
>   //返回条件
>   if(s== graph.length-1)  result.add(new LinkedList<>(path));
>   //dfs
>   for(int i=0;i<graph[s].length;i++){
>       // 做选择
>       path.add(graph[s][i]);
>       dfs(graph,graph[s][i]);
>        // 撤销选择
>       path.removeLast();
>   }
>
>}
>```



>==注==
>
>==什么时候建图：  如果不能通过下标找到下一个节点就得建图==
>
>**就是说  一旦存的是边 就要建图用邻接表存储   否则就不要建图**

#### 图的DFS

##### 有向图是否无环

```java
// 无环判断=收集最终结果集 + traverse + 构建依赖关系	
	boolean visited[];
    boolean path[];
//visited 记录哪些节点被遍历过，而 onPath 记录当前递归堆栈中有哪些节点，它们的作用不同，所以并不重复。


//如果有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程。
    boolean hasCycle = false;
    boolean canFinish(int numCourses, int[][] prerequisites) {
        // 根据现有左边建立树
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
		// 初始化数组
        visited = new boolean[numCourses];
        path = new boolean[numCourses];
		// 避免由于 不连通分量导致的错误，所以对每一个节点 都要进行一次 dfs
        for(int i  = 0; i < numCourses; i++){
            dfs(graph, i);
        }
        // 收集结果
        return !hasCycle;  
    }
```



##### 拓扑排序<是逆后序 >

>==<是逆后序 != 先序>==

```java
  // 拓扑 = 成环判断 +收集最终结果集 + traverse + 构建依赖关系
    boolean visited[];
    boolean path[];
    boolean hasCycle = false;
 //拓扑排序的区别一
List<Integer> res = new LinkedList<>();  


 	public int[] findOrder(int numCourses, int[][] prerequisites) {
            List<Integer>[] graph = buildGraph(numCourses, prerequisites);
            visited = new boolean[numCourses];
            path = new boolean[numCourses];
            for(int i = 0;i< numCourses;i++) {
                dfs(graph, i);
        	}
        

//拓扑排序的区别二
if(hasCycle){
//一个空的整型数组
return new int[]{};
}
            
//拓扑排序的区别三    
        // 反转 ；达成逆后序结果
Collections.reverse(res);
int result[] = new int[numCourses];
for (int i = 0; i <numCourses; i++) {
   result[i] = res.get(i);
}
 return  result;
		
    }

```

##### 复用的代码

```java
 void dfs (List<Integer>[] graph, int s) {
        //  path[s] == true  表示已经走过了，所以是环
        if(path[s])  hasCycle= true;
        if(visited[s] || hasCycle)   return;
     	visited[s] = true;
        path[s] = true;
     
        for(int i : graph[s]){
            dfs(graph, i);
        }
        // 后序位置        //环检测不需要这一段代码
        //  res.add(s);---- 拓扑排序需要进行一个结果收集所以需要加上这一段代码						
        path[s] = false;
    }

		// numCourses: 课程数 即  prerequisites[][] 的 不同的元素个数
    //根据邻接表去创建一个图  将 输入的  prerequisites[][]   转化为邻接表形式
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        //  将 prerequisites[][] 存储的边 转为用邻接表的形式进行存储
        LinkedList<Integer>[] graph = new LinkedList[numCourses];
        // 转换数据类型   graph[i] 从 LinkedList（null）  转化为  [] 数组类型
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        // 将每一个边 存到邻接表中graph
        for(int[] edge:prerequisites) {
            //定义正常的依赖关系
            int from = edge[1];
            int to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }
        return graph;
    }
```

#### BFS

>有向图 的 BFS 中  通过 `indegree` 数组实现的 `visited` 数组的作用，只有入度为 0 的节点才能入队，从而保证不会出现死循环。

##### 有向图是否无环、拓扑排序

>解耦写法
>
>- 有无环
>
>```java
>class Solution {
>   int count =0;
>   int []indegree;     // 取代 visited
>    Queue<Integer> queue = new LinkedList<>();
>   public boolean canFinish(int numCourses, int[][] prerequisites) {
>       indegree = new int[numCourses];
>       List<Integer> [] graph = build(numCourses, prerequisites);
>//入度
>       for (int edge[]: prerequisites) {
>           int to = edge[0];
>           indegree[to]++;
>       }
>//入队
>       for (int i = 0; i < numCourses; i++) {
>           if(indegree[i] == 0 ){
>              queue.offer(i);
>             // count++;  //入队的时候 ++ 
>           }
>       }
>//bfs
>       bfs(graph);
>       return count == numCourses;
>   }
>
>
>
>
>   private void bfs(List<Integer>[] graph) {
>       while(!queue.isEmpty()) {
>           Integer poll = queue.poll();
>            count++;  //出队的时候 ++ 
>           for (int j : graph[poll]) {
>               indegree[j]--;
>               if(indegree[j] == 0) {
>                   queue.offer(j);
>                  // count++;  //入队的时候 ++ 
>               }
>           }
>       }
>   }
>   //建图
>   private List<Integer>[] build(int numCourses, int[][] prerequisites) {
>       List<Integer> []graph = new LinkedList[numCourses];
>       for (int i = 0; i < numCourses; i++) {
>           graph[i] = new LinkedList<>();
>       }
>       for (int []edge : prerequisites) {
>           int from  = edge[1];
>           int to = edge[0];
>           graph[from].add(to);
>       }
>       return graph;
>   }
>}
>```
>
>- 拓扑排序
>
>```java
>class Solution {
>   Queue<Integer> queue= new LinkedList<>();
>   int[] res ;
>   int indegree[] ;
>   int count = 0;
>   public int[] findOrder(int numCourses, int[][] prerequisites) {
>       List<Integer> []graph = build(numCourses, prerequisites);
>       indegree = new int[numCourses];
>       for (int []edge : prerequisites){
>           int to = edge[0];
>           indegree[to]++;
>       }
>
>       for (int i = 0; i < numCourses; i++) {
>           if(indegree[i] == 0){
>               queue.offer(i); 
>           }
>       }
>       res = new int[numCourses];
>       bfs(graph);
>       if(count != numCourses){
>           return new int[]{};
>       }  
>       return res;
>   }
>
>   private void bfs(List<Integer>[] graph) {
>
>       while(!queue.isEmpty()) {
>          Integer poll = queue.poll();
>          res[count]=poll;
>            count++;   //出队的时候加到结果集   并且进行++ 
>           for (int i : graph[poll]) {
>               indegree[i]--;
>               if(indegree[i] == 0) {
>                   queue.offer(i);
>
>               }
>           }
>       }
>   }
>//建图
>   private List<Integer>[] build(int numCourses, int[][] prerequisites) {
>       List<Integer> []graph = new LinkedList[numCourses];
>       for (int i = 0; i < numCourses; i++) {
>           graph[i] = new LinkedList<>();
>       }
>       for (int []edge : prerequisites) {
>           int from  = edge[1];
>           int to = edge[0];
>           graph[from].add(to);
>       }
>       return graph;
>   }
>}
>```
>
>

```java
 // 1、建图，有向边代表「被依赖」关系
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        // 2、建立入度数组
        int[] degree = new int[numCourses];
		// 根据 题目中的边的关系 对  入度数组  进行  赋值操作	
        for(int []edge :prerequisites){
            int from = edge[1];
            int to = edge[0];  //从其他处 来的
            degree[to]++;
        }
        //3、建立队列
        Queue<Integer> queue = new LinkedList<>();
        //4、判断入度数目，将可能 的起点 加到队列中
        for(int i = 0; i < numCourses; i++){
            if(degree[i] == 0){
                //只要节点 i 没有入度，即没有依赖的节点,就把他作为拓扑排序的起点，加入队列
                queue.offer(i);
            }
        }
        int count =0;
        //5、 取出对头元素，每次 取到一个 就让 count ++

//int res[] = new int[numCourses]; //BFS 区别一

        while(!queue.isEmpty()) {
         int current = queue.poll();
            
//res[count] = current;  // 弹出的队列元素的顺序就是拓扑排序的结果 //BFS 区别二
            
            
            count++;
        //6、 将邻居节点的入度 -1
            for(int next:graph[current]){
                degree[next]--;
        //7、邻居节点的个数为 0 也加到队列中
                if(degree[next] == 0){
                    queue.offer(next);
                }
            }
        }
        //8、 如果所有节点都被遍历过，说明不成环
//也就是说  只要有环  就必然会至少有1个节点的入度个数>0 就会使得count！=numCourses,就会有环----false
            return count == numCourses;      -------true  无环

                
                
                
                
// 拓扑排序
//if(count != numCourses){   //BFS 区别三
//   return new int[]{};
//}
//return res;
```

>==其实比判定环的代码就多了几行，添加到指定集合中，从而获取拓扑排序==
>
>**流程**
>
>​	 	1、建图，有向边代表「被依赖」关系
>​        2、建立入度数组
>​        3、建立队列
>​        4、判断入度数目，将所有可能 的起点(入度为  0  ) 加到队列中
>​                只要节点 i 没有入度，即没有依赖的节点,就把他作为拓扑排序的起点，加入队列
>​        5、 取出队头元素，每次 取到一个 就让 count ++
>​        6、 将邻居节点的入度 -1
>​        7、邻居节点的个数为 0 也加到队列中
>​        8、 如果所有节点都被遍历过，说明不成环



##### 复用的代码

```java
//根据邻接表去创建一个图  将 输入的  prerequisites[][]   转化为邻接表形式
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for(int[] edge:prerequisites) {
            //定义正常的依赖关系
            int from = edge[1];
            int to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }
        return graph;
    }
```

#### 二分图

>< 图中  各个节点  的状态 只有两个 可进行选取 >

##### 二分图判定思路

>**二分图怎么判断，其实就是让 `dfs` 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样**。

```java
/* 二分图遍历框架 */
void dfs(Graph graph, boolean[] visited, int v) {
    visited[v] = true;
    // 遍历节点 v 的所有相邻节点 neighbor
    for (int neighbor : graph.neighbors(v)) {
         // 相邻节点 neighbor 没有被访问过
        if (!visited[neighbor]) {
           
            // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色
            
           dfs(graph, visited, neighbor);
            
        // 相邻节点 neighbor 已经被访问过
        } else {
            
            // 那么应该比较节点 neighbor 和节点 v 的颜色
            // 若相同，则此图不是二分图
        }
    }
}

```

##### 判定

>已知邻接表  或者邻接矩阵  不要建图   所谓的 `graph[][]` 的形参就是  邻接表/ 邻接矩阵的表示方法

###### BFS

```java
            boolean color[];
            boolean visited[];
            boolean isbipartiteGraph = true;
            public boolean isBipartite(int[][] graph) {
                int n =graph.length;
                color = new boolean[n];
                visited = new boolean[n];
                //应对 多个 不连通 的 子图的时候
                for (int i = 0; i < n; i++) {
                    if(!visited[i]) {
bfs(graph, i);
                    }
                }
                return isbipartiteGraph;
            }

             void bfs(int[][] graph, int start) {
                 if(!isbipartiteGraph)  return ;
Queue<Integer> queue = new LinkedList<>();
visited[start] = true;
queue.offer(start);
                 while (!queue.isEmpty()){
                     int i = queue.poll();
                     // 邻居节点
                    for(int j:graph[i]) {
                        if(!visited[j]){
                            color[j] = !color[i];
visited[j] =true;
// 邻居节点进队
queue.offer(j);
                        }else{
                            if(color[j] == color[i]){
                                isbipartiteGraph = false;
                                return ;
                            }
                        }
                    }
                 }
             }
```



###### DFS

```java
        class Solution {

            boolean color[];
            boolean visited[];
            boolean isbipartiteGraph = true;
            public boolean isBipartite(int[][] graph) {
                int n = graph.length;
                color =new boolean[n];
                visited = new boolean[n];
                // 应对出现  不联通子图的 情况
                for(int i = 0; i < n; i++){
                    if(!visited[i])  
//和 BFS 的区别 一
dfs(graph,i);
                }
                return  isbipartiteGraph;
            }

//和 BFS 的区别二
void dfs(int[][] graph, int i) {
               if(!isbipartiteGraph) return;
visited[i] = true;
                for(int j: graph[i]) {
                    if (!visited[j]) {
                        //上 不同的色
                        color[j] = !color[i];
//继续递归
dfs(graph, j);
                    } else {
                        //判断颜色一不一样
                        if (color[j] == color[i]) {
                            isbipartiteGraph = false;
                            return;
                        }
                    }
                }
             }
        }


```

#### 可能的二分图<DFS、BFS>

>只给出了各个节点 和什么节点相连  就要建图

```java
 	boolean color[];
    boolean visited[];
    boolean bipartiteGraph = true;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        //索引 偏移
       color = new boolean[n+1];
         //索引 偏移
       visited = new boolean[n+1];
       List<Integer>[] graph =  buildGraph(n,dislikes);
         //索引 偏移
        
        for (int i = 1; i <= n; i++) {
         //   if(!visited[i])
            dfs(graph,i);   //bfs(graph, i); 
       // }
        return bipartiteGraph;

    }
//dfs
     void dfs(List<Integer>[] graph, int i) {
        if(!bipartiteGraph)  return;
        visited[i] = true;
        for(int j:graph[i]) {
            if(!visited[j]){
                color[j] = !color[i];
                dfs(graph,j);
            }else{
                if(color[j] == color[i]){
                    bipartiteGraph = false;
                    return ;
                }
            }
        }
    }
//bfs
     void bfs(List<Integer>[] graph, int start) {
         if(!bipartiteGraph) return ;
         Queue<Integer> queue = new LinkedList<>();
         visited[start]=true;
         queue.offer(start);
         while(!queue.isEmpty()){
            //遍历 每一个弹出队列的邻接节点（邻居）
            int i = queue.poll();
            for(int j:graph[i]){
                if(!visited[j]){
                    color[j] = !color[i];
                    visited[j]=true;
                    queue.offer(j);
                }else{
                    if(color[j]==color[i]){
                        bipartiteGraph = false;
                        return ;
                    }
                }
            }
        }
     }
```

##### 建无向图

```java
      // 建图的 邻接矩阵表示法
    List<Integer>[] buildGraph(int n,int[][] dislikes){
        // 下标 从一 开始  所以会有索引 偏移
        List<Integer>[]graph = new LinkedList[n+1];
          //索引 偏移  初始化
        for (int i = 1; i <=n; i++) {
            graph[i] = new LinkedList<Integer>();
        }
        for(int[]edge:dislikes) {
            int from = edge[1];
            int to = edge[0];
            graph[from].add(to);
            graph[to].add(from);
        }
        return graph;
    }
```

>上面两题的bfs dfs 是一模一样，  只有主函数有些区别，一方面是：多了个 **建图**   另一方面是由于题目问题导致的**索引偏移**

#### Union Find  并查集

###### 主要需要实现这两个 API：

```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}

```

>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：
>
>1、自反性：节点 `p` 和 `p` 是连通的。
>
>2、对称性：如果节点 `p` 和 `q` 连通，那么 `q` 和 `p` 也连通。
>
>3、传递性：如果节点 `p` 和 `q` 连通，`q` 和 `r` 连通，那么 `p` 和 `r` 也连通。

>因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。

>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。

```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的父节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    /* 其他函数 */
}

```

>**如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上**;
>
>**这样，如果节点 `p` 和 `q` 连通的话，它们一定拥有相同的根节点**;
>
>

```java
class UF {
    // 连通分量个数
    private int count;
    // 存储每个节点的父节点
    private int[] parent;

    // n 为图中节点的个数
    public UF(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        
        if (rootP == rootQ)
            return;
        
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 返回图中的连通分量个数
    public int count() {
        return count;
    }
}
```

>总结一下我们优化算法的过程：
>
>1、用 `parent` 数组记录每个节点的父节点，相当于指向父节点的指针，所以 `parent` 数组内实际存储着一个森林（若干棵多叉树）。
>
>2、用 `size` 数组记录着每棵树的重量，目的是让 `union` 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。
>
>3、在 `find` 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 `size` 数组的平衡优化。

>==注== 二维坐标 `(x,y)` 可以转换成 `x * n + y` 这个数（`m` 是棋盘的行数，`n` 是棋盘的列数），**敲黑板，这是将二维坐标映射到一维的常用技巧**。

```java 
   public boolean equationsPossible(String[] equations) {
        Union_Find union_find = new Union_Find(26);
        for(String eq:equations) {
            // 先让相等的字母形成 连通分量
            if (eq.charAt(1) == '=') {
                char x = eq.charAt(0);
                char y = eq.charAt(3);
                //转为数字
                union_find.union(x - 'a', y - 'a');
            }
        }

        // 要是有不等的就判断不等的是不是 相连通的 
        for(String eq:equations){
            if(eq.charAt(1) == '!'){
                char x= eq.charAt(0);
                char y = eq.charAt(3);
                //转为数字   != 还连通了那肯定就是错了
               if(union_find.connection(x-'a',y-'a')) return false;
            }
            
        }
        return true;
    }
// 并将上述的unionFind 代码框架进行复写
```


